#include "pwjppp.h"

#define POLYCRC32   0xEDB88320u /* CRC32 polynomial */
#define POLYCRC24Q  0x1864CFBu  /* CRC24Q polynomial */


int brdcFlag = 0;
int ssrFlag = 0;

const static double leaps[][7] = { /* leap seconds {y,m,d,h,m,s,utc-gpst,...} */
	{ 2017, 1, 1, 0, 0, 0, 18 },
	{ 2015, 7, 1, 0, 0, 0, 17 },
	{ 2012, 7, 1, 0, 0, 0, 16 },
	{ 2009, 1, 1, 0, 0, 0, 15 },
	{ 2006, 1, 1, 0, 0, 0, 14 },
	{ 1999, 1, 1, 0, 0, 0, 13 },
	{ 1997, 7, 1, 0, 0, 0, 12 },
	{ 1996, 1, 1, 0, 0, 0, 11 },
	{ 1994, 7, 1, 0, 0, 0, 10 },
	{ 1993, 7, 1, 0, 0, 0, 9 },
	{ 1992, 7, 1, 0, 0, 0, 8 },
	{ 1991, 1, 1, 0, 0, 0, 7 },
	{ 1990, 1, 1, 0, 0, 0, 6 },
	{ 1988, 1, 1, 0, 0, 0, 5 },
	{ 1985, 7, 1, 0, 0, 0, 4 },
	{ 1983, 7, 1, 0, 0, 0, 3 },
	{ 1982, 7, 1, 0, 0, 0, 2 },
	{ 1981, 7, 1, 0, 0, 0, 1 }
};

const double chisqr[100] = {      /* chi-sqr(n) (alpha=0.001) */
	10.8,13.8,16.3,18.5,20.5,22.5,24.3,26.1,27.9,29.6,
	31.3,32.9,34.5,36.1,37.7,39.3,40.8,42.3,43.8,45.3,
	46.8,48.3,49.7,51.2,52.6,54.1,55.5,56.9,58.3,59.7,
	61.1,62.5,63.9,65.2,66.6,68.0,69.3,70.7,72.1,73.4,
	74.7,76.0,77.3,78.6,80.0,81.3,82.6,84.0,85.4,86.7,
	88.0,89.3,90.6,91.9,93.3,94.7,96.0,97.4,98.7,100 ,
	101 ,102 ,103 ,104 ,105 ,107 ,108 ,109 ,110 ,112 ,
	113 ,114 ,115 ,116 ,118 ,119 ,120 ,122 ,123 ,125 ,
	126 ,127 ,128 ,129 ,131 ,132 ,133 ,134 ,135 ,137 ,
	138 ,139 ,140 ,142 ,143 ,144 ,145 ,147 ,148 ,149
};

const double st0[] = { 1970, 1, 1, 0, 0, 0 };                  //unixϵͳ������Ԫ
const double gpst0[] = { 1980, 1, 6, 0, 0, 0 };                //GPS��ʼʱ
const double gst0[] = { 1999, 8, 22, 0, 0, 0 }; /* galileo system time reference */
const double bdt0[] = { 2006, 1, 1, 0, 0, 0 }; /* beidou time reference */

static double timeoffset_ = 0.0;        /* time offset (s) */

const double lam_carr[] = {       /* carrier wave length (m) */
	CLIGHT / FREQ1, CLIGHT / FREQ2, CLIGHT / FREQ5, CLIGHT / FREQ6, CLIGHT / FREQ7, CLIGHT / FREQ8
};

const prcopt_t prcopt_default = { /* defaults processing options */
	1,PMODE_PPP_STATIC,3,2,SYS_GPS|SYS_GLO|SYS_GAL|SYS_CMP,       /* processRealtime,processMode,frequenceMode,frequenceNumber,navigationSystem */
	7.0,{ { 0,0 } },                      /* elevation,snrmask */
	2,IONOOPT_IFLC,3,0,0,                            /* satelliteEphemeris,ionosphereOption,troposphereOption,modeAR,glonassModeAR */
	5,0,10,1,                             /* maxout,minlock,minfix,dynamics */
	1,1,0,                                /* tideCorrect,nIteration,codeSmooth */
	{ 1000.0,0.003,0.003,0.0,1.0 },       /* err[] */
	{ 100.0 },                            /* eratio[] */
	{ 30.0,0.03,0.3 },                    /* std[] */
	{ 1E-7,1E-2,1E-4,1,1 },               /* processNoise[] */
	{ 5E-12,5E-12,5E-12,5E-12 },          /* prn_isb[] */
	5E-12,                                /* sclkstab */
	{ 3.0,0.9999,0.25,0.1,0.05 },         /* thresholdAR */
	0.0,0.0,0.05,2.0,                     /* elevationAR,elevationHoldAR,thresholdGFSlip,thresholdWLSlip */
	30.0,30.0,30.0,                       /* maxtdif,maxinno,maxgdop */
	0,{ 0 },"*",{ 0 },{ { 0 } },{ 0 },    /* rovpos,fixPosition[],anttype[],antdel[],pcvr,exsats[] */
	{ 1,1,1,1,1,0,1 },                    /* posopt[] */
	1,{ 0 },0,0,1,0,{ 1,1,1,0,0,0 },      /* syncsol,odisp[],robust,adapt,doppler,trajec,csopt[] */
	{ { 0 } },1.0,3,1,{ 0 },0             /* prctime[][],interval,dcbCorrect,useglo,pppopt[],sbassatsel */
};
const solopt_t solopt_default = { /* defaults solution output options */
	SOLF_LLH,TIMES_GPST,1,3,    /* posf,times,timef,timeu */
	0,1,0,0,0,0,0,              /* degf,outhead,outopt,outvel,datum,height,geoid */
	0,0,0,                      /* solstatic,sstat,trace */
	{ 0.0,0.0 },                  /* nmeaintv */
	" ","",                      /* separator/program name */
	5.0
};


/* crc tables generated by util/gencrc ---------------------------------------*/
static const unsigned short tbl_CRC16[] = {
	0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50A5, 0x60C6, 0x70E7,
	0x8108, 0x9129, 0xA14A, 0xB16B, 0xC18C, 0xD1AD, 0xE1CE, 0xF1EF,
	0x1231, 0x0210, 0x3273, 0x2252, 0x52B5, 0x4294, 0x72F7, 0x62D6,
	0x9339, 0x8318, 0xB37B, 0xA35A, 0xD3BD, 0xC39C, 0xF3FF, 0xE3DE,
	0x2462, 0x3443, 0x0420, 0x1401, 0x64E6, 0x74C7, 0x44A4, 0x5485,
	0xA56A, 0xB54B, 0x8528, 0x9509, 0xE5EE, 0xF5CF, 0xC5AC, 0xD58D,
	0x3653, 0x2672, 0x1611, 0x0630, 0x76D7, 0x66F6, 0x5695, 0x46B4,
	0xB75B, 0xA77A, 0x9719, 0x8738, 0xF7DF, 0xE7FE, 0xD79D, 0xC7BC,
	0x48C4, 0x58E5, 0x6886, 0x78A7, 0x0840, 0x1861, 0x2802, 0x3823,
	0xC9CC, 0xD9ED, 0xE98E, 0xF9AF, 0x8948, 0x9969, 0xA90A, 0xB92B,
	0x5AF5, 0x4AD4, 0x7AB7, 0x6A96, 0x1A71, 0x0A50, 0x3A33, 0x2A12,
	0xDBFD, 0xCBDC, 0xFBBF, 0xEB9E, 0x9B79, 0x8B58, 0xBB3B, 0xAB1A,
	0x6CA6, 0x7C87, 0x4CE4, 0x5CC5, 0x2C22, 0x3C03, 0x0C60, 0x1C41,
	0xEDAE, 0xFD8F, 0xCDEC, 0xDDCD, 0xAD2A, 0xBD0B, 0x8D68, 0x9D49,
	0x7E97, 0x6EB6, 0x5ED5, 0x4EF4, 0x3E13, 0x2E32, 0x1E51, 0x0E70,
	0xFF9F, 0xEFBE, 0xDFDD, 0xCFFC, 0xBF1B, 0xAF3A, 0x9F59, 0x8F78,
	0x9188, 0x81A9, 0xB1CA, 0xA1EB, 0xD10C, 0xC12D, 0xF14E, 0xE16F,
	0x1080, 0x00A1, 0x30C2, 0x20E3, 0x5004, 0x4025, 0x7046, 0x6067,
	0x83B9, 0x9398, 0xA3FB, 0xB3DA, 0xC33D, 0xD31C, 0xE37F, 0xF35E,
	0x02B1, 0x1290, 0x22F3, 0x32D2, 0x4235, 0x5214, 0x6277, 0x7256,
	0xB5EA, 0xA5CB, 0x95A8, 0x8589, 0xF56E, 0xE54F, 0xD52C, 0xC50D,
	0x34E2, 0x24C3, 0x14A0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,
	0xA7DB, 0xB7FA, 0x8799, 0x97B8, 0xE75F, 0xF77E, 0xC71D, 0xD73C,
	0x26D3, 0x36F2, 0x0691, 0x16B0, 0x6657, 0x7676, 0x4615, 0x5634,
	0xD94C, 0xC96D, 0xF90E, 0xE92F, 0x99C8, 0x89E9, 0xB98A, 0xA9AB,
	0x5844, 0x4865, 0x7806, 0x6827, 0x18C0, 0x08E1, 0x3882, 0x28A3,
	0xCB7D, 0xDB5C, 0xEB3F, 0xFB1E, 0x8BF9, 0x9BD8, 0xABBB, 0xBB9A,
	0x4A75, 0x5A54, 0x6A37, 0x7A16, 0x0AF1, 0x1AD0, 0x2AB3, 0x3A92,
	0xFD2E, 0xED0F, 0xDD6C, 0xCD4D, 0xBDAA, 0xAD8B, 0x9DE8, 0x8DC9,
	0x7C26, 0x6C07, 0x5C64, 0x4C45, 0x3CA2, 0x2C83, 0x1CE0, 0x0CC1,
	0xEF1F, 0xFF3E, 0xCF5D, 0xDF7C, 0xAF9B, 0xBFBA, 0x8FD9, 0x9FF8,
	0x6E17, 0x7E36, 0x4E55, 0x5E74, 0x2E93, 0x3EB2, 0x0ED1, 0x1EF0
};
static const unsigned int tbl_CRC24Q[] = {
	0x000000, 0x864CFB, 0x8AD50D, 0x0C99F6, 0x93E6E1, 0x15AA1A, 0x1933EC, 0x9F7F17,
	0xA18139, 0x27CDC2, 0x2B5434, 0xAD18CF, 0x3267D8, 0xB42B23, 0xB8B2D5, 0x3EFE2E,
	0xC54E89, 0x430272, 0x4F9B84, 0xC9D77F, 0x56A868, 0xD0E493, 0xDC7D65, 0x5A319E,
	0x64CFB0, 0xE2834B, 0xEE1ABD, 0x685646, 0xF72951, 0x7165AA, 0x7DFC5C, 0xFBB0A7,
	0x0CD1E9, 0x8A9D12, 0x8604E4, 0x00481F, 0x9F3708, 0x197BF3, 0x15E205, 0x93AEFE,
	0xAD50D0, 0x2B1C2B, 0x2785DD, 0xA1C926, 0x3EB631, 0xB8FACA, 0xB4633C, 0x322FC7,
	0xC99F60, 0x4FD39B, 0x434A6D, 0xC50696, 0x5A7981, 0xDC357A, 0xD0AC8C, 0x56E077,
	0x681E59, 0xEE52A2, 0xE2CB54, 0x6487AF, 0xFBF8B8, 0x7DB443, 0x712DB5, 0xF7614E,
	0x19A3D2, 0x9FEF29, 0x9376DF, 0x153A24, 0x8A4533, 0x0C09C8, 0x00903E, 0x86DCC5,
	0xB822EB, 0x3E6E10, 0x32F7E6, 0xB4BB1D, 0x2BC40A, 0xAD88F1, 0xA11107, 0x275DFC,
	0xDCED5B, 0x5AA1A0, 0x563856, 0xD074AD, 0x4F0BBA, 0xC94741, 0xC5DEB7, 0x43924C,
	0x7D6C62, 0xFB2099, 0xF7B96F, 0x71F594, 0xEE8A83, 0x68C678, 0x645F8E, 0xE21375,
	0x15723B, 0x933EC0, 0x9FA736, 0x19EBCD, 0x8694DA, 0x00D821, 0x0C41D7, 0x8A0D2C,
	0xB4F302, 0x32BFF9, 0x3E260F, 0xB86AF4, 0x2715E3, 0xA15918, 0xADC0EE, 0x2B8C15,
	0xD03CB2, 0x567049, 0x5AE9BF, 0xDCA544, 0x43DA53, 0xC596A8, 0xC90F5E, 0x4F43A5,
	0x71BD8B, 0xF7F170, 0xFB6886, 0x7D247D, 0xE25B6A, 0x641791, 0x688E67, 0xEEC29C,
	0x3347A4, 0xB50B5F, 0xB992A9, 0x3FDE52, 0xA0A145, 0x26EDBE, 0x2A7448, 0xAC38B3,
	0x92C69D, 0x148A66, 0x181390, 0x9E5F6B, 0x01207C, 0x876C87, 0x8BF571, 0x0DB98A,
	0xF6092D, 0x7045D6, 0x7CDC20, 0xFA90DB, 0x65EFCC, 0xE3A337, 0xEF3AC1, 0x69763A,
	0x578814, 0xD1C4EF, 0xDD5D19, 0x5B11E2, 0xC46EF5, 0x42220E, 0x4EBBF8, 0xC8F703,
	0x3F964D, 0xB9DAB6, 0xB54340, 0x330FBB, 0xAC70AC, 0x2A3C57, 0x26A5A1, 0xA0E95A,
	0x9E1774, 0x185B8F, 0x14C279, 0x928E82, 0x0DF195, 0x8BBD6E, 0x872498, 0x016863,
	0xFAD8C4, 0x7C943F, 0x700DC9, 0xF64132, 0x693E25, 0xEF72DE, 0xE3EB28, 0x65A7D3,
	0x5B59FD, 0xDD1506, 0xD18CF0, 0x57C00B, 0xC8BF1C, 0x4EF3E7, 0x426A11, 0xC426EA,
	0x2AE476, 0xACA88D, 0xA0317B, 0x267D80, 0xB90297, 0x3F4E6C, 0x33D79A, 0xB59B61,
	0x8B654F, 0x0D29B4, 0x01B042, 0x87FCB9, 0x1883AE, 0x9ECF55, 0x9256A3, 0x141A58,
	0xEFAAFF, 0x69E604, 0x657FF2, 0xE33309, 0x7C4C1E, 0xFA00E5, 0xF69913, 0x70D5E8,
	0x4E2BC6, 0xC8673D, 0xC4FECB, 0x42B230, 0xDDCD27, 0x5B81DC, 0x57182A, 0xD154D1,
	0x26359F, 0xA07964, 0xACE092, 0x2AAC69, 0xB5D37E, 0x339F85, 0x3F0673, 0xB94A88,
	0x87B4A6, 0x01F85D, 0x0D61AB, 0x8B2D50, 0x145247, 0x921EBC, 0x9E874A, 0x18CBB1,
	0xE37B16, 0x6537ED, 0x69AE1B, 0xEFE2E0, 0x709DF7, 0xF6D10C, 0xFA48FA, 0x7C0401,
	0x42FA2F, 0xC4B6D4, 0xC82F22, 0x4E63D9, 0xD11CCE, 0x575035, 0x5BC9C3, 0xDD8538
};
const  int constallation[] = { SYS_GPS, SYS_GLO, SYS_GAL, SYS_CMP, SYS_SBS };
const char constallationid[] = "GRECS"; 

extern void trace(int level, const char *format, ...) {}
extern void tracet(int level, const char *format, ...) {}

/* execute command -------------------------------------------------------------
* execute command line by operating system shell
* args   : char   *cmd      I   command line
* return : execution status (0:ok,0>:error)
*-----------------------------------------------------------------------------*/
extern int execcmd(const char *cmd)
{
#ifdef WIN32
	PROCESS_INFORMATION info;
	STARTUPINFO si = { 0 };
	DWORD stat;
	char cmds[1024];

	trace(3, "execcmd: cmd=%s\n", cmd);

	si.cb = sizeof(si);
	sprintf(cmds, "cmd /c %s", cmd);
	if (!CreateProcess(NULL, (LPTSTR)cmds, NULL, NULL, FALSE, CREATE_NO_WINDOW, NULL,
		NULL, &si, &info)) return -1;
	WaitForSingleObject(info.hProcess, INFINITE);
	if (!GetExitCodeProcess(info.hProcess, &stat)) stat = -1;
	CloseHandle(info.hProcess);
	CloseHandle(info.hThread);
	return (int)stat;
#else
	trace(3, "execcmd: cmd=%s\n", cmd);

	return system(cmd);
#endif
}

/* uncompress file -------------------------------------------------------------
* uncompress (uncompress/unzip/uncompact hatanaka-compression/tar) file
* args   : char   *file     I   input file
*          char   *uncfile  O   uncompressed file
* return : status (-1:error,0:not compressed file,1:uncompress completed)
* note   : creates uncompressed file in tempolary directory
*          gzip and crx2rnx commands have to be installed in commands path
*-----------------------------------------------------------------------------*/
extern int uncompress(const char *file, char *uncfile)
{
	int stat = 0;
	char *p, cmd[2048] = "", tmpfile[1024] = "", buff[1024], *fname, *dir = "";

	trace(3, "uncompress: file=%s\n", file);

	strcpy(tmpfile, file);
	if (!(p = strrchr(tmpfile, '.'))) return 0;

	/* uncompress by gzip */
	if (!strcmp(p, ".z") || !strcmp(p, ".Z") ||
		!strcmp(p, ".gz") || !strcmp(p, ".GZ") ||
		!strcmp(p, ".zip") || !strcmp(p, ".ZIP")) {

		strcpy(uncfile, tmpfile); uncfile[p - tmpfile] = '\0';
		sprintf(cmd, "gzip -f -d -c \"%s\" > \"%s\"", tmpfile, uncfile);

		if (execcmd(cmd)) {
			remove(uncfile);
			return -1;
		}
		strcpy(tmpfile, uncfile);
		stat = 1;
	}
	/* extract tar file */
	if ((p = strrchr(tmpfile, '.')) && !strcmp(p, ".tar")) {

		strcpy(uncfile, tmpfile); uncfile[p - tmpfile] = '\0';
		strcpy(buff, tmpfile);
		fname = buff;
#ifdef WIN32
		if ((p = strrchr(buff, '\\'))) {
			*p = '\0'; dir = fname; fname = p + 1;
		}
		sprintf(cmd, "set PATH=%%CD%%;%%PATH%% & cd /D \"%s\" & tar -xf \"%s\"",
			dir, fname);
#else
		if ((p = strrchr(buff, '/'))) {
			*p = '\0'; dir = fname; fname = p + 1;
		}
		sprintf(cmd, "tar -C \"%s\" -xf \"%s\"", dir, tmpfile);
#endif
		if (execcmd(cmd)) {
			if (stat) remove(tmpfile);
			return -1;
		}
		if (stat) remove(tmpfile);
		stat = 1;
	}
	/* extract hatanaka-compressed file by cnx2rnx */
	else if ((p = strrchr(tmpfile, '.')) && strlen(p)>3 && (*(p + 3) == 'd' || *(p + 3) == 'D')) {

		strcpy(uncfile, tmpfile);
		uncfile[p - tmpfile + 3] = *(p + 3) == 'D' ? 'O' : 'o';
		sprintf(cmd, "crx2rnx < \"%s\" > \"%s\"", tmpfile, uncfile);

		if (execcmd(cmd)) {
			remove(uncfile);
			if (stat) remove(tmpfile);
			return -1;
		}
		if (stat) remove(tmpfile);
		stat = 1;
	}
	trace(3, "uncompress: stat=%d\n", stat);
	return stat;
}

extern int stable_func(char *line, char* sep, char **str)
{
	int i;
	int n = 0;
	int width = 0;
	for (i = 0; i<(int)strlen(line); i++)
	{
		if (line[i] == sep[0])
		{
			if (width == 0)
				strcpy(str[n++], " ");
			else
			{
				strncpy(str[n], line + i - width, width);
				str[n++][width] = '\0';
				width = 0;
			}
			if (n == 18)
			{
				strcpy(str[n++], i == strlen(line) - 1 ? " " : line + i + 1);
				break;
			}
			continue;
		}
		width++;
	}
	return n;
}

extern int strtok_func(char *line, char* sep, char **str) {
	int n = 0;
	char *p = NULL;
	p = strtok(line, sep);
	while (p != NULL) {
		strcpy(str[n++], p);
		p = strtok(NULL, sep);
	}
	return n;
}
extern char *strtok_blank(char *line)
{
	int i, ns = 0, ne = 0, nlen = 0;
	nlen = (int)strlen(line);
	for (i = 0; i < nlen; i++)
	{
		if (line[i] == ' ')
			ns++;
		else
			break;
	}
	for (i = nlen - 1; i >= 0; i--)
	{
		if (line[i] == ' ')
			ne++;
		else
			break;
	}
	line[nlen - ne] = '\0';
	return line + ns;
}

/* extract unsigned/signed bits ------------------------------------------------
* extract unsigned/signed bits from byte data
* args   : unsigned char *buff I byte data
*          int    pos    I      bit position from start of data (bits)
*          int    len    I      bit length (bits) (len<=32)
* return : extracted unsigned/signed bits
*-----------------------------------------------------------------------------*/
extern unsigned int getbitu(const unsigned char *buff, int pos, int len)
{
	unsigned int bits = 0;
	int i;
	for (i = pos; i<pos + len; i++) bits = (bits << 1) + ((buff[i / 8] >> (7 - i % 8)) & 1u);
	return bits;
}
extern int getbits(const unsigned char *buff, int pos, int len)
{
	unsigned int bits = getbitu(buff, pos, len);
	if (len <= 0 || 32 <= len || !(bits&(1u << (len - 1)))) return (int)bits;
	return (int)(bits | (~0u << len)); /* extend sign */
}

/* set unsigned/signed bits ----------------------------------------------------
* set unsigned/signed bits to byte data
* args   : unsigned char *buff IO byte data
*          int    pos    I      bit position from start of data (bits)
*          int    len    I      bit length (bits) (len<=32)
*         (unsigned) int I      unsigned/signed data
* return : none
*-----------------------------------------------------------------------------*/
extern void setbitu(unsigned char *buff, int pos, int len, unsigned int data)
{
	unsigned int mask = 1u << (len - 1);
	int i;
	if (len <= 0 || 32<len) return;
	for (i = pos; i<pos + len; i++, mask >>= 1) {
		if (data&mask) buff[i / 8] |= 1u << (7 - i % 8); else buff[i / 8] &= ~(1u << (7 - i % 8));
	}
}
extern void setbits(unsigned char *buff, int pos, int len, int data)
{
	if (data<0) data |= 1 << (len - 1); else data &= ~(1 << (len - 1)); /* set sign bit */
	setbitu(buff, pos, len, (unsigned int)data);
}

/* crc-32 parity ---------------------------------------------------------------
* compute crc-32 parity for novatel raw
* args   : unsigned char *buff I data
*          int    len    I      data length (bytes)
* return : crc-32 parity
* notes  : see NovAtel OEMV firmware manual 1.7 32-bit CRC
*-----------------------------------------------------------------------------*/
extern unsigned int crc32(const unsigned char *buff, int len)
{
	unsigned int crc = 0;
	int i, j;

	for (i = 0; i<len; i++) {
		crc ^= buff[i];
		for (j = 0; j<8; j++) {
			if (crc & 1) crc = (crc >> 1) ^ POLYCRC32; else crc >>= 1;
		}
	}
	return crc;
}

/* crc-24q parity --------------------------------------------------------------
* compute crc-24q parity for sbas, rtcm3
* args   : unsigned char *buff I data
*          int    len    I      data length (bytes)
* return : crc-24Q parity
* notes  : see reference [2] A.4.3.3 Parity
*-----------------------------------------------------------------------------*/
extern unsigned int crc24q(const unsigned char *buff, int len)
{
	unsigned int crc = 0;
	int i;
	for (i = 0; i<len; i++) crc = ((crc << 8) & 0xFFFFFF) ^ tbl_CRC24Q[(crc >> 16) ^ buff[i]];
	return crc;
}

/* crc-16 parity ---------------------------------------------------------------
* compute crc-16 parity for binex, nvs
* args   : unsigned char *buff I data
*          int    len    I      data length (bytes)
* return : crc-16 parity
* notes  : see reference [10] A.3.
*-----------------------------------------------------------------------------*/
extern unsigned short crc16(const unsigned char *buff, int len)
{
	unsigned short crc = 0;
	int i;

	//    trace(4,"crc16: len=%d\n",len);

	for (i = 0; i<len; i++) {
		crc = (crc << 8) ^ tbl_CRC16[((crc >> 8) ^ buff[i]) & 0xFF];
	}
	return crc;
}
/* decode navigation data word -------------------------------------------------
* check party and decode navigation data word
* args   : unsigned int word I navigation data word (2+30bit)
*                              (previous word D29*-30* + current word D1-30)
*          unsigned char *data O decoded navigation data without parity
*                              (8bitx3)
* return : status (1:ok,0:parity error)
* notes  : see reference [1] 20.3.5.2 user parity algorithm
*-----------------------------------------------------------------------------*/
extern int decode_word(unsigned int word, unsigned char *data)
{
	const unsigned int hamming[] = {
		0xBB1F3480,0x5D8F9A40,0xAEC7CD00,0x5763E680,0x6BB1F340,0x8B7A89C0
	};
	unsigned int parity = 0, w;
	int i;

	//    trace(5,"decodeword: word=%08x\n",word);

	if (word & 0x40000000) word ^= 0x3FFFFFC0;

	for (i = 0; i<6; i++) {
		parity <<= 1;
		for (w = (word&hamming[i]) >> 6; w; w >>= 1) parity ^= w & 1;
	}
	if (parity != (word & 0x3F)) return 0;

	for (i = 0; i<3; i++) data[i] = (unsigned char)(word >> (22 - i * 8));
	return 1;
}



extern int isleapyear(int year)
{
	if (year % 100 == 0)
	{
		if (year % 400 == 0)
			return 1;
		else
			return 0;
	}
	else if (year % 4 == 0)
		return 1;
	else
		return 0;
}

extern gtime_t utc2gpst(gtime_t second)
{
	return timeadd(second, leapsecond(second));
}

extern gtime_t gpst2utc(gtime_t second)
{
	return timeadd(second, -leapsecond(second));
}


extern int timestr2ep(char *str, double *ep)
{
	if (sscanf(str, "%lf%lf%lf%lf%lf%lf", ep, ep + 1, ep + 2, ep + 3, ep + 4, ep + 5)<6) return 0;
	if (ep[0]<100)
		ep[0] += ep[0]>80 ? 1900 : 2000;
	return 1;
}
extern double timediff(gtime_t t1, gtime_t t2)
{
	return difftime(t1.time, t2.time) + t1.sec - t2.sec;
}

extern gtime_t timeadd(gtime_t t1, double t2)
{
	double tt;

	t1.sec += t2; tt = floor(t1.sec); t1.time += (int)tt; t1.sec -= tt;
	return t1;
}
extern int leapsecond(gtime_t second)
{
	int i;
	for (i = 0; i<(int)sizeof(leaps) / (int)sizeof(*leaps); i++)
	{
		if (timediff(second, epoch2time(leaps[i])) >= 0)
			return (int)leaps[i][6];
	}
	return 0;
}


extern gtime_t bdt2gpst(gtime_t t)
{
	return timeadd(t, 14.0);
}

extern gtime_t gpst2bdt(gtime_t t)
{
	return timeadd(t, -14.0);
}

extern gtime_t bdt2time(int week, double second)
{
	gtime_t t;
	t = epoch2time(bdt0);

	if (second<-1E9 || 1E9<second) second = 0.0;
	t.time += 86400 * 7 * week + (int)second;
	t.sec = second - (int)second;
	return t;
}

extern double time2bdt(gtime_t t, int *week)
{
	gtime_t t0 = epoch2time(bdt0);
	time_t sec = t.time - t0.time;
	int w = (int)(sec / (86400 * 7));

	if (week) *week = w;
	return (double)(sec - w * 86400 * 7) + t.sec;
}

extern double MJD2JD(double MJD)
{
	return MJD + 2400000.5;
}
/*Compute true sidereal time  (in hours) at Greenwich at 0 hours UT*/
extern double getSidTime(gtime_t time)
{
	double jd, jc, sid;
	jd = MJD2JD(time2mjd(time));
	jc = (jd - 2451545.0) / 36525;/*Compute the Julian centuries (36525 days)*/
	sid = 24110.54841 + jc * (8640184.812866
		+ jc * (0.093104 - jc * 0.0000062));// Compute the sidereal time, in seconds

	sid = sid / 3600.0;
	sid = fmod(sid, 24.0);
	if (sid < 0.0) sid = sid + 24.0;

	return sid;
}



extern double time2gpst(gtime_t t, int *week)
{
	gtime_t t0 = epoch2time(gpst0);
	time_t sec = t.time - t0.time;
	int w = (int)(sec / (86400 * 7));
	if (week) *week = w;
	return (double)(sec - w * 86400 * 7) + t.sec;
}



extern void time2epoch(gtime_t t, double *ep)
{
	const int fymday[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31,
		31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31,
		31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31,
		31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
	int ndays, mon, sec, days;

	days = (int)(t.time / 86400);
	sec = (int)(t.time - (time_t)days * 86400);

	for (ndays = days % 1461, mon = 0; mon<48; mon++) 
	{
		if (ndays >= fymday[mon])
			ndays -= fymday[mon];
		else
			break;
	}
	ep[0] = (int)st0[0] + days / 1461 * 4 + mon / 12;
	ep[1] = mon % 12 + 1;
	ep[2] = ndays + 1;
	ep[3] = sec / 3600;
	ep[4] = sec % 3600 / 60;
	ep[5] = sec%60 + t.sec;
}


extern void mjd2epoch(double mjd, double *ep)
{
	int a = 0;
	int b = 0;
	int c = 0;
	int d = 0;
	int e = 0;
	double tmp = 0.0;
	a = (int)(mjd + 0.5);
	b = a + 1537;
	c = (int)((b - 122.1) / 365.25);
	d = (int)(365.25 * c);
	e = (int)((b - d) / 30.6001);
	ep[5] = modf(modf(mjd + 0.5, &tmp) * 24, &tmp);
	ep[3] = (int)(tmp);
	ep[5] = modf(ep[5] * 60, &tmp);
	ep[4] = (int)(tmp);
	ep[5] = ep[5] * 60;
	ep[2] = b - d - (int)(30.6001 * e);
	ep[1] = e - 1 - 12 * (int)(e / 14);
	ep[0] = c - 4715 - (int)((7 + ep[1]) / 10);
}


extern int epoch2doy(const double *ep, int *year)
{
	int doy,y;
	const int sday[] = { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334 };
	y = (int)ep[0];
	if (year) *year = y;
	doy = sday[(int)ep[1] - 1] + (int)ep[2] + (isleapyear((int)ep[0]) && (int)ep[1] > 2 ? 1 : 0);
	return doy;
}

extern int time2doy(gtime_t time, int *year)
{
	double ep[6];
	time2epoch(time, ep);
	return epoch2doy(ep,year);
}

extern gtime_t epoch2time(const double *ep)
{
	gtime_t s;
	const int doy[] = { 1, 32, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335 };
	int year = (int)ep[0], month = (int)ep[1], day = (int)ep[2], days;
	days = (year - 1970) * 365 + (year - 1969) / 4 + doy[month - 1] + day - 2 + (isleapyear(year) && month>2 ? 1 : 0);
	s.time = (time_t)days * 86400 + ((int)ep[3]) * 3600 + ((int)ep[4]) * 60 + (int)floor(ep[5]);
	s.sec = ep[5] - (int)floor(ep[5]);
	return s;
}


extern gtime_t gpst2time(int week, double sec)
{
	gtime_t asecond = epoch2time(gpst0);//days=3657
	asecond.time = asecond.time + week * 7 * 86400 + (int)sec;
	asecond.sec = sec - (int)sec;
	return asecond;
}

extern gtime_t doy2time(int year, int doy)
{
	gtime_t s;
	int days;
	days = (year - 1970) * 365 + (year - 1969) / 4 + doy - 1;
	s.time = (time_t)days * 86400;
	s.sec = 0.0;
	return s;
}
extern gtime_t mjd2time(double mjd)
{
	double ep[6];
	mjd2epoch(mjd,ep);
	return epoch2time(ep);
}


extern double epoch2mjd(const double *ep)
{
	double mjd;
	if ((int)ep[1] > 2)
		mjd = (int)(365.25*ep[0]) + (int)(30.6001*(ep[1] + 1))
		+ (int)ep[2]/* + ((int)ep[3] +(int)(ep[4]) / 60 + (int)(ep[5]) / 3600) / 24*/ - 679019;
	else
		mjd = (int)(365.25*(ep[0] - 1)) + (int)(30.6001*(ep[1] + 1 + 12))
		+ (int)ep[2] /*+ ((int)ep[3] + ep[4] / 60 + ep[5] / 3600) / 24*/ - 679019;
	return mjd;
}

extern double gpst2mjd(int week, double sec)
{
	double mjd;
	mjd = week * 7 + sec / 86400 + 44244;
	return mjd;
}

extern double doy2mjd(int year, int doy)
{
	double mjd;
	mjd = (int)(365.25*(year - 1)) + doy - 678591;
	return mjd;
}

extern double time2mjd(gtime_t t)
{
	double mjd;
	mjd = 44244 - 3657 + ((int)((double)t.time / 604800)) * 7 + ((double)t.time - ((int)((double)t.time / 604800)) * 604800) / 86400;
	return mjd;
}




extern gtime_t adjweek(gtime_t t, gtime_t t0)
{
	double tt = timediff(t, t0);
	if (tt<-302400.0) return timeadd(t, 604800.0);
	if (tt> 302400.0) return timeadd(t, -604800.0);
	return t;
}

extern gtime_t adjday(gtime_t t, gtime_t t0)
{
	double tt = timediff(t, t0);
	if (tt<-43200.0) return timeadd(t, 86400.0);
	if (tt> 43200.0) return timeadd(t, -86400.0);
	return t;
}

extern gtime_t timeget(void)
{
	double ep[6] = { 0 };
#ifdef WIN32
	SYSTEMTIME ts;

	GetSystemTime(&ts); /* utc */
	ep[0] = ts.wYear; ep[1] = ts.wMonth;  ep[2] = ts.wDay;
	ep[3] = ts.wHour; ep[4] = ts.wMinute; ep[5] = ts.wSecond + ts.wMilliseconds*1E-3;
#else
	struct timeval tv;
	struct tm *tt;

	if (!gettimeofday(&tv, NULL) && (tt = gmtime(&tv.tv_sec))) {
		ep[0] = tt->tm_year + 1900; ep[1] = tt->tm_mon + 1; ep[2] = tt->tm_mday;
		ep[3] = tt->tm_hour; ep[4] = tt->tm_min; ep[5] = tt->tm_sec + tv.tv_usec*1E-6;
	}
#endif
	return timeadd(epoch2time(ep), timeoffset_);
}

/* set current time in utc -----------------------------------------------------
* set current time in utc
* args   : gtime_t          I   current time in utc
* return : none
* notes  : just set time offset between cpu time and current time
*          the time offset is reflected to only timeget()
*          not reentrant
*-----------------------------------------------------------------------------*/
extern void timeset(gtime_t t)
{
	timeoffset_ += timediff(t, timeget());
}

/* get tick time ---------------------------------------------------------------
* get current tick in ms
* args   : none
* return : current tick in ms
*-----------------------------------------------------------------------------*/
extern unsigned int tickget(void)
{
#ifdef WIN32
	return (unsigned int)timeGetTime();
#else
	struct timespec tp = { 0 };
	struct timeval  tv = { 0 };

#ifdef CLOCK_MONOTONIC_RAW
	/* linux kernel > 2.6.28 */
	if (!clock_gettime(CLOCK_MONOTONIC_RAW, &tp)) {
		return tp.tv_sec * 1000u + tp.tv_nsec / 1000000u;
	}
	else {
		gettimeofday(&tv, NULL);
		return tv.tv_sec * 1000u + tv.tv_usec / 1000u;
	}
#else
	gettimeofday(&tv, NULL);
	return tv.tv_sec * 1000u + tv.tv_usec / 1000u;
#endif
#endif /* WIN32 */
}
/* sleep ms --------------------------------------------------------------------
* sleep ms
* args   : int   ms         I   miliseconds to sleep (<0:no sleep)
* return : none
*-----------------------------------------------------------------------------*/
extern void sleepms(int ms)
{
#ifdef WIN32
	if (ms<5) Sleep(1); else Sleep(ms);
#else
	struct timespec ts;
	if (ms <= 0) return;
	ts.tv_sec = (time_t)(ms / 1000);
	ts.tv_nsec = (long)(ms % 1000 * 1000000);
	nanosleep(&ts, NULL);
#endif
}

/* create directory ------------------------------------------------------------
* create directory if not exist
* args   : char   *path     I   file path to be saved
* return : none
* notes  : not recursive. only one level
*-----------------------------------------------------------------------------*/
extern void createdir(const char *path)
{
	char buff[1024], *p;

	/*    tracet(3,"createdir: path=%s\n",path);*/

	strcpy(buff, path);
	if (!(p = strrchr(buff, FILEPATHSEP))) return;
	*p = '\0';

#ifdef WIN32
	CreateDirectory(buff, NULL);
#else
	mkdir(buff, 0777);
#endif
}
/* replace string ------------------------------------------------------------*/
static int repstr(char *str, const char *pat, const char *rep)
{
	int len = strlen(pat);
	char buff[1024], *p, *q, *r;

	for (p = str, r = buff; *p; p = q + len) {
		if (!(q = strstr(p, pat))) break;
		strncpy(r, p, q - p);
		r += q - p;
		r += sprintf(r, "%s", rep);
	}
	if (p <= str) return 0;
	strcpy(r, p);
	strcpy(str, buff);
	return 1;
}
/* replace keywords in file path -----------------------------------------------
* replace keywords in file path with date, time, rover and base station id
* args   : char   *path     I   file path (see below)
*          char   *rpath    O   file path in which keywords replaced (see below)
*          gtime_t time     I   time (gpst)  (time.time==0: not replaced)
*          char   *rov      I   rover id string        ("": not replaced)
*          char   *base     I   base station id string ("": not replaced)
* return : status (1:keywords replaced, 0:no valid keyword in the path,
*                  -1:no valid time)
* notes  : the following keywords in path are replaced by date, time and name
*              %Y -> yyyy : year (4 digits) (1900-2099)
*              %y -> yy   : year (2 digits) (00-99)
*              %m -> mm   : month           (01-12)
*              %d -> dd   : day of month    (01-31)
*              %h -> hh   : hours           (00-23)
*              %M -> mm   : minutes         (00-59)
*              %S -> ss   : seconds         (00-59)
*              %n -> ddd  : day of year     (001-366)
*              %W -> wwww : gps week        (0001-9999)
*              %D -> d    : day of gps week (0-6)
*              %H -> h    : hour code       (a=0,b=1,c=2,...,x=23)
*              %ha-> hh   : 3 hours         (00,03,06,...,21)
*              %hb-> hh   : 6 hours         (00,06,12,18)
*              %hc-> hh   : 12 hours        (00,12)
*              %t -> mm   : 15 minutes      (00,15,30,45)
*              %r -> rrrr : rover id
*              %b -> bbbb : base station id
*-----------------------------------------------------------------------------*/
extern int reppath(const char *path, char *rpath, gtime_t time, const char *rov,
	const char *base)
{
	double ep[6], ep0[6] = { 2000,1,1,0,0,0 };
	int week, dow, doy, stat = 0;
	char rep[64];

	strcpy(rpath, path);

	if (!strstr(rpath, "%")) return 0;
	if (*rov) stat |= repstr(rpath, "%r", rov);
	if (*base) stat |= repstr(rpath, "%b", base);
	if (time.time != 0) {
		time2epoch(time, ep);
		ep0[0] = ep[0];
		dow = (int)floor(time2gpst(time, &week) / 86400.0);
		doy = (int)floor(timediff(time, epoch2time(ep0)) / 86400.0) + 1;
		sprintf(rep, "%02d", ((int)ep[3] / 3) * 3);   stat |= repstr(rpath, "%ha", rep);
		sprintf(rep, "%02d", ((int)ep[3] / 6) * 6);   stat |= repstr(rpath, "%hb", rep);
		sprintf(rep, "%02d", ((int)ep[3] / 12) * 12); stat |= repstr(rpath, "%hc", rep);
		sprintf(rep, "%04.0f", ep[0]);              stat |= repstr(rpath, "%Y", rep);
		sprintf(rep, "%02.0f", fmod(ep[0], 100.0));  stat |= repstr(rpath, "%y", rep);
		sprintf(rep, "%02.0f", ep[1]);              stat |= repstr(rpath, "%m", rep);
		sprintf(rep, "%02.0f", ep[2]);              stat |= repstr(rpath, "%d", rep);
		sprintf(rep, "%02.0f", ep[3]);              stat |= repstr(rpath, "%h", rep);
		sprintf(rep, "%02.0f", ep[4]);              stat |= repstr(rpath, "%M", rep);
		sprintf(rep, "%02.0f", floor(ep[5]));       stat |= repstr(rpath, "%S", rep);
		sprintf(rep, "%03d", doy);                stat |= repstr(rpath, "%n", rep);
		sprintf(rep, "%04d", week);               stat |= repstr(rpath, "%W", rep);
		sprintf(rep, "%d", dow);                stat |= repstr(rpath, "%D", rep);
		sprintf(rep, "%c", 'a' + (int)ep[3]);     stat |= repstr(rpath, "%H", rep);
		sprintf(rep, "%02d", ((int)ep[4] / 15) * 15); stat |= repstr(rpath, "%t", rep);
	}
	else if (strstr(rpath, "%ha") || strstr(rpath, "%hb") || strstr(rpath, "%hc") ||
		strstr(rpath, "%Y") || strstr(rpath, "%y") || strstr(rpath, "%m") ||
		strstr(rpath, "%d") || strstr(rpath, "%h") || strstr(rpath, "%M") ||
		strstr(rpath, "%S") || strstr(rpath, "%n") || strstr(rpath, "%W") ||
		strstr(rpath, "%D") || strstr(rpath, "%H") || strstr(rpath, "%t")) {
		return -1; /* no valid time */
	}
	/*    trace(3,"reppath : rpath=%s\n",rpath);*/
	return stat;
}

extern int adjgpsweek(int week)
{
	int w;
	time2gpst(timeadd(timeget(), leapsecond(timeget())),&w);
	if (w<1560) w = 1560; /* use 2009/12/1 if time is earlier than 2009/12/1 */
	return week + (w - week + 512) / 1024 * 1024;
}

/* adjust weekly rollover of bdt time ----------------------------------------*/
extern int adjbdtweek(int week)
{
	int w;
	(void)time2bdt(gpst2bdt(utc2gpst(timeget())), &w);
	if (w<1) w = 1; /* use 2006/1/1 if time is earlier than 2006/1/1 */
	return week + (w - week + 512) / 1024 * 1024;
}


extern double str2num(const char *s, int i, int n)
{
	double value;
	char str[256], *p = str;

	if (i<0 || (int)strlen(s)<i || (int)sizeof(str) - 1<n) return 0.0;
	for (s += i; *s&&--n >= 0; s++) *p++ = *s == 'd' || *s == 'D' ? 'E' : *s; *p = '\0';
	return sscanf(str, "%lf", &value) == 1 ? value : 0.0;
}

extern char* numInH2str(char *s, int n)
{
	char s_t[4] = { 0 };
	sprintf(s_t, "%d", n);
	if (n < 10)
	{
		strcpy(s, "0");
		strcat(s, s_t);
	}
	else
		strcpy(s, s_t);
	return s;
}


extern int satID2satIndex(char *satID)
{
	int sys, prn;
	char code;
	if (sscanf(satID, "%d", &prn) == 1) {
		if (MINPRNGPS <= prn&&prn <= MAXPRNGPS) sys = SYS_GPS;
		else if (MINPRNSBS <= prn&&prn <= MAXPRNSBS) sys = SYS_SBS;
		else return 0;
		return satno2satIndex(sys, prn);
	}
	if (sscanf(satID, "%c%d", &code, &prn)<2) return 0;
	switch (code) {
	case 'G': sys = SYS_GPS; prn += MINPRNGPS - 1; break;
	case 'R': sys = SYS_GLO; prn += MINPRNGLO - 1; break;
	case 'E': sys = SYS_GAL; prn += MINPRNGAL - 1; break;
	case 'C': sys = SYS_CMP; prn += MINPRNCMP - 1; break;
	case 'S': sys = SYS_SBS; prn += 100;             break;
	default: return 0;
	}
	return satno2satIndex(sys, prn);
}

extern char* satIndex2satID(char *s, int satIndex)
{
	char s_num[3] = { 0 };
	if (satIndex == 0)
		return "";
	if (satIndex <= NSATGPS)
	{
		strcpy(s, "G");
		strcpy(s_num, numInH2str(s_num, satIndex + MINPRNGPS - 1));
		strcat(s, s_num);
		return s;
	}
	else if ((satIndex -= NSATGPS) <= NSATGLO)
	{
		strcpy(s, "R");
		strcpy(s_num, numInH2str(s_num, satIndex + MINPRNGLO - 1));
		strcat(s, s_num);
		return s;
	}
	else if ((satIndex -= NSATGLO) <= NSATGAL)
	{
		strcpy(s, "E");
		strcpy(s_num, numInH2str(s_num, satIndex + MINPRNGAL - 1));
		strcat(s, s_num);
		return s;
	}
	else if ((satIndex -= NSATGAL) <= NSATCMP)
	{
		strcpy(s, "C");
		strcpy(s_num, numInH2str(s_num, satIndex + MINPRNCMP - 1));
		strcat(s, s_num);
		return s;
	}
	else if ((satIndex -= NSATCMP) <= NSATSBS)
	{
		strcpy(s, "S");
		strcpy(s_num, numInH2str(s_num, satIndex + MINPRNSBS - 1 - 100));
		strcat(s, s_num);
		return s;
	}
	else
	{
		printf("Sat index is not available!\n");
		strcpy(s, "");
		return "";
	}
}


int satIndex2sys(int satIndex)//GPS+GLONASS+GALILEO+BDS
{
	if (satIndex == 0)
		return -1;
	if (satIndex <= NSATGPS)
		return SYS_GPS;
	else if (satIndex <= NSATGPS + NSATGLO)
		return SYS_GLO;
	else if (satIndex <= NSATGPS + NSATGLO + NSATGAL)
		return SYS_GAL;
	else if (satIndex <= NSATGPS + NSATGLO + NSATGAL + NSATCMP)
		return SYS_CMP;
	else if (satIndex <= NSATGPS + NSATGLO + NSATGAL + NSATCMP + NSATSBS)
		return SYS_SBS;
	else
	{
		printf("Sat index is not available!\n");
		return 0;
	}
}

//��ǰ׺��������G32��sys=G��prn=32��R24��sys=R��prn=24
int satno2satIndex(int sys, int prn)
{
	/*	char s[5] = { 0 };
	char s_num[4] = { 0 };
	s[0] = sys == SYS_GPS ? 'G' : (sys == SYS_GLO ? 'R' : (sys == SYS_GAL ? 'E' : (sys == SYS_CMP ? 'C' : 'S')));
	if (s[0] == 'S')
	prn -= 100;
	strcpy(s_num, numInH2str(s_num, prn));
	strcat(s,s_num);
	return satID2satIndex(s);*/
	if (prn <= 0) return 0;
	switch (sys) {
	case SYS_GPS:
		if (prn<MINPRNGPS || prn>MAXPRNGPS)return 0;
		return prn - MINPRNGPS + 1;
	case SYS_GLO:
		if (prn<MINPRNGLO || prn>MAXPRNGLO)return 0;
		return NSATGPS + prn - MINPRNGLO + 1;
	case SYS_GAL:
		if (prn<MINPRNGAL || prn>MAXPRNGAL)return 0;
		return NSATGPS + NSATGLO + prn - MINPRNGAL + 1;
	case SYS_CMP:
		if (prn<MINPRNCMP || prn>MAXPRNCMP)return 0;
		return NSATGPS + NSATGLO + NSATGAL + prn - MINPRNCMP + 1;
	case SYS_SBS:
		if (prn<MINPRNSBS || MAXPRNSBS<prn) return 0;
		return NSATGPS + NSATGLO + NSATGAL + NSATCMP + prn - MINPRNSBS + 1;
	}
	return 0;
}

int satIndex2satno(int satIndex)
{
	if (satIndex == 0)
		return 0;
	if (satIndex <= NSATGPS)
	{
		return satIndex;
	}
	else if (satIndex <= NSATGPS + NSATGLO)
	{
		return  satIndex - NSATGPS;
	}
	else if (satIndex <= NSATGPS + NSATGLO + NSATGAL)
	{
		return satIndex - NSATGPS - NSATGLO;
	}
	else if (satIndex <= NSATGPS + NSATGLO + NSATGAL + NSATCMP)
	{
		return satIndex - NSATGPS - NSATGLO - NSATGAL;
	}
	else if (satIndex <= NSATGPS + NSATGLO + NSATGAL + NSATCMP + NSATSBS)
	{
		return satIndex - NSATGPS - NSATGLO - NSATGAL - NSATCMP + 20 + 100;
	}
	else
	{
		printf("Sat index is not available!\n");
		return 0;
	}
}



extern char *time2ObsTimeStr(gtime_t time, char* timestr)
{
	//	char s[28] = { 0 };
	double ep[6];
	time2epoch(time,ep);
	sprintf(timestr, "%5d%3d%3d%3d%3d%11.7f", (int)ep[0], (int)ep[1], (int)ep[2], (int)ep[3], (int)ep[4], ep[5]);
	return timestr;
}

extern char *time2BRDCTimeStr(gtime_t time, char* timestr)
{
	//	char s[28] = { 0 };
	double ep[6];
	time2epoch(time, ep);
	sprintf(timestr, "%5d%3d%3d%3d%3d%3d", (int)ep[0], (int)ep[1], (int)ep[2], (int)ep[3], (int)ep[4], (int)ep[5]);
	return timestr;
}

extern char *time2peph_tTimeStr(gtime_t time, char* timestr)
{
	//	char s[28] = { 0 };
	double ep[6];
	time2epoch(time, ep);
	sprintf(timestr, "%4d %02d %02d %02d %02d %011.8f", (int)ep[0], (int)ep[1], (int)ep[2], (int)ep[3], (int)ep[4], ep[5]);
	return timestr;
}

extern char *time2pclk_tTimeStr(gtime_t time, char* timestr)
{
	//	char s[28] = { 0 };
	double ep[6];
	time2epoch(time, ep);
	sprintf(timestr, "%4d %02d %02d %02d %02d %9.6f", (int)ep[0], (int)ep[1], (int)ep[2], (int)ep[3], (int)ep[4], ep[5]);
	return timestr;
}


extern int str2time(const char *buff, int m, int n, gtime_t *time)
{
	double ep[6] = { 0 };
	char str[60] = { 0 };
	strncpy(str, buff + m, n);
	if (sscanf(str, "%lf%lf%lf%lf%lf%lf", ep, ep + 1, ep + 2, ep + 3, ep + 4, ep + 5) < 6)
		return 0;
	if (ep[0]<100.0) ep[0] += ep[0]<80.0 ? 2000.0 : 1900.0;
	*time = epoch2time(ep);
	return 1;
}

/* time to string --------------------------------------------------------------
* convert gtime_t struct to string
* args   : gtime_t t        I   gtime_t struct
*          char   *s        O   string ("yyyy/mm/dd hh:mm:ss.ssss")
*          int    n         I   number of decimals
* return : none
*-----------------------------------------------------------------------------*/
extern void time2str(gtime_t t, char *s, int n)
{
	double ep[6];

	if (n<0) n = 0; else if (n>12) n = 12;
	//4->5   ->   1    0.5 ->1.0
	if (1.0 - t.sec<1.0 / pow(10.0, n)) { t.time++; t.sec = 0.0; };
	time2epoch(t, ep);
	sprintf(s, "%04.0f/%02.0f/%02.0f %02.0f:%02.0f:%0*.*f", ep[0], ep[1], ep[2],
		ep[3], ep[4], n <= 0 ? 2 : n + 3, n <= 0 ? 0 : n, ep[5]);
}

/* get time string -------------------------------------------------------------
* get time string
* args   : gtime_t t        I   gtime_t struct
*          int    n         I   number of decimals
* return : time string
* notes  : not reentrant, do not use multiple in a function
*-----------------------------------------------------------------------------*/
extern char *time_str(gtime_t t, int n)
{
	static char buff[64];
	time2str(t, buff, n);
	return buff;
}



extern char *num2BRDCScientific(double a, char *s_brdc)
{
	int n = 0;
	int i;
	memset(s_brdc, 0, 20);
	for (i = 1;; i++)
	{
		if (a == 0)
			break;

		else if (fabs(a) >= 1.0)
		{
			a /= 10;
			n++;
		}
		else if (fabs(a) < 0.1)
		{
			a *= 10;
			n--;
		}
		else
			break;
	}
	if (n<0)
		sprintf(s_brdc, "%14.12f%s%02d", fabs(a), "E-", abs(n));
	else
		sprintf(s_brdc, "%14.12f%s%02d", fabs(a), "E+", abs(n));

	if (a < 0)
	{
		s_brdc[0] = '-';
		return s_brdc;
	}
	else
		return s_brdc + 1;
}


extern char *num2CLKScientific(double a, char *s_clk)
{
	int n = 0;
	int i;
	memset(s_clk, 0, 20);
	char temp[20] = { 0 };
	for (i = 1;; i++)
	{
		if (a == 0)
			break;

		else if (fabs(a) >= 1.0)
		{
			a /= 10;
			n++;
		}
		else if (fabs(a) < 0.1)
		{
			a *= 10;
			n--;
		}
		else
			break;
	}
	if (n<0)
		sprintf(s_clk, "%14.12f%s%02d", fabs(a), "e-", abs(n));
	else
		sprintf(s_clk, "%14.12f%s%02d", fabs(a), "e+", abs(n));

	if (a < 0)
	{
		strcpy(temp, "-");
		strcat(temp, s_clk);
		strcpy(s_clk, temp);
		return s_clk;
	}
	else
		return s_clk;
}


extern double dot_vector(const double *a, const double *b, int n)
{
	double c = 0.0;
	int i;
	for (i = 0; i < n; i++)
		c += a[i] * b[i];
	return c;
}

extern double norm(const double *a, int n)
{
	double c = 0.0;
	int i;
	for (i = 0; i < n; i++)
		c += a[i] * a[i];
	return sqrt(c);
}

/* normalize 3d vector ---------------------------------------------------------
* normalize 3d vector
* args   : double *a        I   vector a (3 x 1)
*          double *b        O   normlized vector (3 x 1) || b || = 1
* return : status (1:ok,0:error)
*-----------------------------------------------------------------------------*/
extern int normv3(const double *a, double *b)
{
	double r;
	if ((r = norm(a, 3)) <= 0.0) return 0;
	b[0] = a[0] / r;
	b[1] = a[1] / r;
	b[2] = a[2] / r;
	return 1;
}

/* outer product of 3d vectors -------------------------------------------------
* outer product of 3d vectors
* args   : double *a,*b     I   vector a,b (3 x 1)
*          double *c        O   outer product (a x b) (3 x 1)
* return : none
*-----------------------------------------------------------------------------*/
extern void cross3(const double *a, const double *b, double *c)
{
	c[0] = a[1] * b[2] - a[2] * b[1];
	c[1] = a[2] * b[0] - a[0] * b[2];
	c[2] = a[0] * b[1] - a[1] * b[0];
}


extern char *str2nstr(const char *buff, int n, int m)
{
	static char str[1024] = { 0 };
	strncpy(str, buff + n, m);
	str[m] = '\0';
	return str;
}


/* ionosphere model ------------------------------------------------------------
* compute ionospheric delay by broadcast ionosphere model (klobuchar model)
* args   : gtime_t  t      I   time (gpst)
*          double *ion      I   iono model parameters {a0,a1,a2,a3,b0,b1,b2,b3}
*          double *pos      I   receiver position {lat,lon,h} (rad,m)
*          double *azel     I   azimuth/elevation angle {az,el} (rad)
* return : ionospheric delay (L1) (m)
*-----------------------------------------------------------------------------*/
extern double ionmodel(gtime_t t, const double *ion, const double *pos,
	const double *azel)
{
	const double ion_default[] = { /* 2004/1/1 */
		0.1118E-07, -0.7451E-08, -0.5961E-07, 0.1192E-06,
		0.1167E+06, -0.2294E+06, -0.1311E+06, 0.1049E+07
	};
	double tt, f, psi, phi, lam, amp, per, x;

	if (pos[2]<-1E3 || azel[1] <= 0) return 0.0;
	if (norm(ion, 8) <= 0.0) ion = ion_default;

	/* earth centered angle (semi-circle) */
	psi = 0.0137 / (Angle2Radian(azel[1]) / PI + 0.11) - 0.022;

	/* subionospheric latitude/longitude (semi-circle) */
	phi = Angle2Radian(pos[0]) / PI + psi*cos(Angle2Radian(azel[0]));
	if (phi> 0.416) phi = 0.416;
	else if (phi<-0.416) phi = -0.416;
	lam = Angle2Radian(pos[1]) / PI + psi*sin(Angle2Radian(azel[0])) / cos(phi*PI);

	/* geomagnetic latitude (semi-circle) */
	phi += 0.064*cos((lam - 1.617)*PI);

	/* local time (s) */
	tt = 43200.0*lam + time2gpst(t,NULL);
	tt -= floor(tt / 86400.0)*86400.0; /* 0<=tt<86400 */

									   /* slant factor */
	f = 1.0 + 16.0*pow(0.53 - Angle2Radian(azel[1]) / PI, 3.0);

	/* ionospheric delay */
	amp = ion[0] + phi*(ion[1] + phi*(ion[2] + phi*ion[3]));
	per = ion[4] + phi*(ion[5] + phi*(ion[6] + phi*ion[7]));
	amp = amp<    0.0 ? 0.0 : amp;
	per = per<72000.0 ? 72000.0 : per;
	x = 2.0*PI*(tt - 50400.0) / per;

	return CLIGHT*f*(fabs(x)<1.57 ? 5E-9 + amp*(1.0 + x*x*(-0.5 + x*x / 24.0)) : 5E-9);
}
/* ionosphere mapping function -------------------------------------------------
* compute ionospheric delay mapping function by single layer model
* args   : double *pos      I   receiver position {lat,lon,h} (rad,m)
*          double *azel     I   azimuth/elevation angle {az,el} (rad)
* return : ionospheric mapping function
*-----------------------------------------------------------------------------*/
extern double ionmapf(const double *pos, const double *azel)
{
	if (pos[2] >= HION) return 1.0;
	return 1.0 / cos(asin((A_WGS84 + pos[2]) / (A_WGS84 + HION)*sin(PI / 2.0 - Angle2Radian(azel[1]))));
}
/* ionospheric pierce point position -------------------------------------------
* compute ionospheric pierce point (ipp) position and slant factor
* args   : double *pos      I   receiver position {lat,lon,h} (rad,m)
*          double *azel     I   azimuth/elevation angle {az,el} (rad)
*          double re        I   earth radius (km)
*          double hion      I   altitude of ionosphere (km)
*          double *posp     O   pierce point position {lat,lon,h,jiajiao} (rad,m)
* return : slant factor
* notes  : see ref [2], only valid on the earth surface
*          fixing bug on ref [2] A.4.4.10.1 A-22,23
*-----------------------------------------------------------------------------*/
extern double ionppp(const double *pos, const double *azel, double re,
	double hion, double *posp)
{
	double cosaz, rp, ap, sinap, tanap;
	//	rp = re / (re + hion)*cos(Angle2Radian(azel[1]));
	rp = (re + pos[2]) / (re + hion)*cos(Angle2Radian(azel[1]));
	ap = PI / 2.0 - Angle2Radian(azel[1]) - asin(rp);
	sinap = sin(ap);
	tanap = tan(ap);
	cosaz = cos(Angle2Radian(azel[0]));
	posp[0] = asin(sin(Angle2Radian(pos[0]))*cos(ap) + cos(Angle2Radian(pos[0]))*sinap*cosaz);

	if ((pos[0]> 0.0&& tanap*cosaz>tan(PI / 2.0 - Angle2Radian(pos[0]))) ||
		(pos[0]<-0.0&&-tanap*cosaz>tan(PI / 2.0 + Angle2Radian(pos[0])))) {
		posp[1] = Angle2Radian(pos[1]) + PI - asin(sinap*sin(Angle2Radian(azel[0])) / cos(posp[0]));
	}
	else {
		posp[1] = Angle2Radian(pos[1]) + asin(sinap*sin(Angle2Radian(azel[0])) / cos(posp[0]));
	}
	posp[0] = Radian2Angle(posp[0]);
	posp[1] = Radian2Angle(posp[1]);
	return 1.0 / sqrt(1.0 - rp*rp);
	return 1.0 / sin(ap + Angle2Radian(azel[1]));
}


static double getcosc(double *c, int N, int M, int n, int m)
{
	int index;
	index = (N + 1 + (N + 2 - m))*m / 2 + n - m;
	return c[index];
}

static double getsinc(double *c, int N, int M, int n, int m)
{
	if (m == 0)
		return 0.0;
	int index;
	int cosSum = 0;
	cosSum = ((N + 1) + (N + 1 - M))*(M + 1) / 2;
	index = cosSum + (N + (N + 1 - (m - 1)))*(m - 1) / 2 + n - m;
	return c[index];
}


static int getcofind(int N, int M, int n, int m)
{
	return (N + 1 + (N + 2 - m))*m / 2 + n - m;
}
static int getfactorial(int n)
{
	int i, sum = 1;
	if (n == 0)
		return 1;
	else
	{
		for (i = 1; i <= n; i++)
			sum *= i;
	}
	return sum;
}


/*generate fully normalized associated Legendre functions*/

static void genfnaleg(const double sinp, const int N, const int M, double *pnm)
{
	int i, j;
	int  ind1, ind2;
	int s = 0;
	if (N >= 0)
		pnm[s++] = 1.0;
	if (N >= 1)
		pnm[s++] = sinp;
	if (N >= 2)
	{
		for (i = 2; i <= N; i++)
		{
			pnm[s++] = (pnm[i - 1] * sinp*(2 * i - 1) - pnm[i - 2] * (i - 1)) / i;
		}
	}

	for (i = 1; i <= M; i++)
	{
		for (j = i; j <= N; j++)
		{
			ind1 = getcofind(N, M, j - 1, i - 1);
			ind2 = getcofind(N, M, j, i - 1);
			pnm[s++] = (pnm[ind1] * (j + i + 1) - pnm[ind2] * sinp*(j - i + 1)) / sqrt(1 - sinp*sinp);
		}
	}

}


extern double norm_legendre(int n, int m, double thta)//thta （单位：弧度）      按列
{
	double u = sin(thta);
	double t = cos(thta);
	if (n == m)
	{
		if (n == 0)
		{
			return 1.0;
		}
		else if (n == 1)
		{
			return sqrt(3)*u;
		}
		else if (n>1)
		{
			return u*sqrt((2 * m + 1.0) / (2.0*m))*norm_legendre(m - 1, m - 1, thta);
		}
	}

	if (n > m)
	{
		double a = sqrt((2 * n - 1.0)*(2 * n + 1) / (n - m) / (n + m));
		double b = sqrt((2 * n + 1.0)*(n + m - 1)*(n - m - 1) / (n - m) / (n + m) / (2 * n - 3));

		return a*t*norm_legendre(n - 1, m, thta) - b*norm_legendre(n - 2, m, thta);
	}

	if (n<m)
	{
		return 0.0;
	}
	return 0.0;
}

/*ssr vtec*/
extern int ssrstec(gtime_t time, ssrion_t tec, const double *pos, const double *azel, int opt, double *delay, double *var)
{
	const double fact = 40.30E16 / FREQ1 / FREQ1; /* tecu->L1 iono (m) */
	const double re = 6370000;
	double fs, posp[3] = { 0 }, vtec, rms = 2.0, hion/*, rp*/;
	int i, degree, order, n, m, nccof;
	double Cnm, Snm, *Pnm = NULL;
	double coef[MAXTECCOEFF] = { 0.0 };
	int s;

	*delay = *var = 0.0;
	vtec = 0.0;
	double nn = 0;
	hion = tec.vtec[0][0];
	degree = (int)tec.vtec[0][1];
	order = (int)tec.vtec[0][2];
	nccof = (int)pow(degree + 1, 2) - (degree - order)*(degree - order + 1);

	s = (degree + 1)*(degree + 2) / 2 - (degree - order)*(degree - order + 1) / 2;
	Pnm = (double *)malloc(sizeof(double)*s);

	for (i = 0; i < nccof&&i < MAXTECCOEFF; i++)
		coef[i] = tec.vtec[0][3 + i];

	/* ionospheric pierce point position */
	fs = ionppp(pos, azel, re, hion, posp);
	if (opt & 2) {
		/* modified single layer mapping function (M-SLM) ref [2] */
		//		rp = (re+pos[2]) / (re + hion)*sin(0.9782*(PI / 2.0 - Angle2Radian(azel[1])));
		//		fs = 1.0 / sqrt(1.0 - rp*rp);
	}
	/*	gtime_t t = { 50400,0 };*/
	double mod;
	double f;
	if (opt & 1) {
		/* earth rotation correction (sun-fixed coordinate) */
		mod = modulo(time2gpst(time, NULL) - 50400, 86400);
		f = mod / 86400.0*360.0;
		//	posp[1] = modulo(posp[1]+modulo((time2gpst(time).sec - 50400),86400.0)/86400.0*360.0,360.0);
		posp[1] = modulo(Angle2Radian(posp[1]) + (time2gpst(time, NULL) - 50400)*PI / 43200.0, 2 * PI)*R2D;
	}
	genfnaleg(sin(Angle2Radian(posp[0])), degree, order, Pnm);

	for (n = 0; n <= degree; n++)
	{
		for (m = 0; m <= min(n, order); m++)
		{
			if (m <= n)
			{
				Cnm = getcosc(coef, degree, order, n, m);
				Snm = getsinc(coef, degree, order, n, m);
				//				vtec += (Cnm*cos(m*Angle2Radian(posp[1])) + Snm*sin(m*Angle2Radian(posp[1])))*getfnaleg(degree, order, n, m, Pnm);
				vtec += (Cnm*cos(m*Angle2Radian(posp[1])) + Snm*sin(m*Angle2Radian(posp[1])))*norm_legendre(n, m, PI / 2 - Angle2Radian(posp[0]));
			}
		}
	}

	*delay += fact*fs*vtec;
	*var += fact*fact*fs*fs*rms*rms;
	free(Pnm); Pnm = NULL;
	return 1;
}

/* get meterological parameters ----------------------------------------------*/
static void getmet(double lat, double *met)
{
	static const double metprm[][10] = { /* lat=15,30,45,60,75 */
		{ 1013.25, 299.65, 26.31, 6.30E-3, 2.77, 0.00, 0.00, 0.00, 0.00E-3, 0.00 },
		{ 1017.25, 294.15, 21.79, 6.05E-3, 3.15, -3.75, 7.00, 8.85, 0.25E-3, 0.33 },
		{ 1015.75, 283.15, 11.66, 5.58E-3, 2.57, -2.25, 11.00, 7.24, 0.32E-3, 0.46 },
		{ 1011.75, 272.15, 6.78, 5.39E-3, 1.81, -1.75, 15.00, 5.36, 0.81E-3, 0.74 },
		{ 1013.00, 263.65, 4.11, 4.53E-3, 1.55, -0.50, 14.50, 3.39, 0.62E-3, 0.30 }
	};
	int i, j;
	double a;
	lat = fabs(lat);
	if (lat <= 15.0) for (i = 0; i<10; i++) met[i] = metprm[0][i];
	else if (lat >= 75.0) for (i = 0; i<10; i++) met[i] = metprm[4][i];
	else {
		j = (int)(lat / 15.0); a = (lat - j*15.0) / 15.0;
		for (i = 0; i<10; i++) met[i] = (1.0 - a)*metprm[j - 1][i] + a*metprm[j][i];
	}
}
/* tropospheric delay correction -----------------------------------------------
* compute sbas tropospheric delay correction (mops model)
* args   : gtime_t time     I   time
*          double   *pos    I   receiver position {lat,lon,height} (rad/m)
*          double   *azel   I   satellite azimuth/elavation (rad)
*          double   *var    O   variance of troposphric error (m^2)
* return : slant tropospheric delay (m)
*-----------------------------------------------------------------------------*/
extern double sbstropcorr(gtime_t time, const double *pos, const double *azel,
	double *var)
{
	const double k1 = 77.604, k2 = 382000.0, rd = 287.054, gm = 9.784, g = 9.80665;
	static double pos_[3] = { 0 }, zh = 0.0, zw = 0.0;
	int i;
	double c, met[10], sinel = sin(Angle2Radian(azel[1])), h = pos[2], m;

	if (pos[2]<-100.0 || 10000.0<pos[2] || azel[1] <= 0) {
		*var = 0.0;
		return 0.0;
	}
	if (zh == 0.0 || fabs(Angle2Radian(pos[0]) - pos_[0])>1E-7 || fabs(Angle2Radian(pos[1]) - pos_[1])>1E-7 ||
		fabs(pos[2] - pos_[2])>1.0) {
		getmet(pos[0], met);
		c = cos(2.0*PI*(time2doy(time,NULL) - (Angle2Radian(pos[0]) >= 0.0 ? 28.0 : 211.0)) / 365.25);
		for (i = 0; i<5; i++) met[i] -= met[i + 5] * c;
		zh = 1E-6*k1*rd*met[0] / gm;
		zw = 1E-6*k2*rd / (gm*(met[4] + 1.0) - met[3] * rd)*met[2] / met[1];
		zh *= pow(1.0 - met[3] * h / met[1], g / (rd*met[3]));
		zw *= pow(1.0 - met[3] * h / met[1], (met[4] + 1.0)*g / (rd*met[3]) - 1.0);
		for (i = 0; i<3; i++) pos_[i] = pos[i];
	}
	m = 1.001 / sqrt(0.002001 + sinel*sinel);
	*var = 0.12*0.12*m*m;
	return (zh + zw)*m;
}

static int gptModel(gtime_t time, const double *pos, double *pres, double *temp, double *hort)
{
	const double a_geoid[55] =
	{
		-5.6195e-001,-6.0794e-002,-2.0125e-001,-6.4180e-002,-3.6997e-002,
		+1.0098e+001,+1.6436e+001,+1.4065e+001,+1.9881e+000,+6.4414e-001,
		-4.7482e+000,-3.2290e+000,+5.0652e-001,+3.8279e-001,-2.6646e-002,
		+1.7224e+000,-2.7970e-001,+6.8177e-001,-9.6658e-002,-1.5113e-002,
		+2.9206e-003,-3.4621e+000,-3.8198e-001,+3.2306e-002,+6.9915e-003,
		-2.3068e-003,-1.3548e-003,+4.7324e-006,+2.3527e+000,+1.2985e+000,
		+2.1232e-001,+2.2571e-002,-3.7855e-003,+2.9449e-005,-1.6265e-004,
		+1.1711e-007,+1.6732e+000,+1.9858e-001,+2.3975e-002,-9.0013e-004,
		-2.2475e-003,-3.3095e-005,-1.2040e-005,+2.2010e-006,-1.0083e-006,
		+8.6297e-001,+5.8231e-001,+2.0545e-002,-7.8110e-003,-1.4085e-004,
		-8.8459e-006,+5.7256e-006,-1.5068e-006,+4.0095e-007,-2.4185e-008
	};

	const double b_geoid[55] =
	{
		+0.0000e+000,+0.0000e+000,-6.5993e-002,+0.0000e+000,+6.5364e-002,
		-5.8320e+000,+0.0000e+000,+1.6961e+000,-1.3557e+000,+1.2694e+000,
		+0.0000e+000,-2.9310e+000,+9.4805e-001,-7.6243e-002,+4.1076e-002,
		+0.0000e+000,-5.1808e-001,-3.4583e-001,-4.3632e-002,+2.2101e-003,
		-1.0663e-002,+0.0000e+000,+1.0927e-001,-2.9463e-001,+1.4371e-003,
		-1.1452e-002,-2.8156e-003,-3.5330e-004,+0.0000e+000,+4.4049e-001,
		+5.5653e-002,-2.0396e-002,-1.7312e-003,+3.5805e-005,+7.2682e-005,
		+2.2535e-006,+0.0000e+000,+1.9502e-002,+2.7919e-002,-8.1812e-003,
		+4.4540e-004,+8.8663e-005,+5.5596e-005,+2.4826e-006,+1.0279e-006,
		+0.0000e+000,+6.0529e-002,-3.5824e-002,-5.1367e-003,+3.0119e-005,
		-2.9911e-005,+1.9844e-005,-1.2349e-006,-7.6756e-009,+5.0100e-008
	};

	const double ap_mean[55] =
	{
		+1.0108e+003, +8.4886e+000, +1.4799e+000, -1.3897e+001, +3.7516e-003,
		-1.4936e-001, +1.2232e+001, -7.6615e-001, -6.7699e-002, +8.1002e-003,
		-1.5874e+001, +3.6614e-001, -6.7807e-002, -3.6309e-003, +5.9966e-004,
		+4.8163e+000, -3.7363e-001, -7.2071e-002, +1.9998e-003, -6.2385e-004,
		-3.7916e-004, +4.7609e+000, -3.9534e-001, +8.6667e-003, +1.1569e-002,
		+1.1441e-003, -1.4193e-004, -8.5723e-005, +6.5008e-001, -5.0889e-001,
		-1.5754e-002, -2.8305e-003, +5.7458e-004, +3.2577e-005, -9.6052e-006,
		-2.7974e-006, +1.3530e+000, -2.7271e-001, -3.0276e-004, +3.6286e-003,
		-2.0398e-004, +1.5846e-005, -7.7787e-006, +1.1210e-006, +9.9020e-008,
		+5.5046e-001, -2.7312e-001, +3.2532e-003, -2.4277e-003, +1.1596e-004,
		+2.6421e-007, -1.3263e-006, +2.7322e-007, +1.4058e-007, +4.9414e-009
	};

	const double bp_mean[55] =
	{
		+0.0000e+000, +0.0000e+000, -1.2878e+000, +0.0000e+000, +7.0444e-001,
		+3.3222e-001, +0.0000e+000, -2.9636e-001, +7.2248e-003, +7.9655e-003,
		+0.0000e+000, +1.0854e+000, +1.1145e-002, -3.6513e-002, +3.1527e-003,
		+0.0000e+000, -4.8434e-001, +5.2023e-002, -1.3091e-002, +1.8515e-003,
		+1.5422e-004, +0.0000e+000, +6.8298e-001, +2.5261e-003, -9.9703e-004,
		-1.0829e-003, +1.7688e-004, -3.1418e-005, +0.0000e+000, -3.7018e-001,
		+4.3234e-002, +7.2559e-003, +3.1516e-004, +2.0024e-005, -8.0581e-006,
		-2.3653e-006, +0.0000e+000, +1.0298e-001, -1.5086e-002, +5.6186e-003,
		+3.2613e-005, +4.0567e-005, -1.3925e-006, -3.6219e-007, -2.0176e-008,
		+0.0000e+000, -1.8364e-001, +1.8508e-002, +7.5016e-004, -9.6139e-005,
		-3.1995e-006, +1.3868e-007, -1.9486e-007, +3.0165e-010, -6.4376e-010
	};

	const double ap_amp[55] =
	{
		-1.0444e-001, +1.6618e-001, -6.3974e-002, +1.0922e+000, +5.7472e-001,
		-3.0277e-001, -3.5087e+000, +7.1264e-003, -1.4030e-001, +3.7050e-002,
		+4.0208e-001, -3.0431e-001, -1.3292e-001, +4.6746e-003, -1.5902e-004,
		+2.8624e+000, -3.9315e-001, -6.4371e-002, +1.6444e-002, -2.3403e-003,
		+4.2127e-005, +1.9945e+000, -6.0907e-001, -3.5386e-002, -1.0910e-003,
		-1.2799e-004, +4.0970e-005, +2.2131e-005, -5.3292e-001, -2.9765e-001,
		-3.2877e-002, +1.7691e-003, +5.9692e-005, +3.1725e-005, +2.0741e-005,
		-3.7622e-007, +2.6372e+000, -3.1165e-001, +1.6439e-002, +2.1633e-004,
		+1.7485e-004, +2.1587e-005, +6.1064e-006, -1.3755e-008, -7.8748e-008,
		-5.9152e-001, -1.7676e-001, +8.1807e-003, +1.0445e-003, +2.3432e-004,
		+9.3421e-006, +2.8104e-006, -1.5788e-007, -3.0648e-008, +2.6421e-010
	};

	const double bp_amp[55] =
	{
		+0.0000e+000, +0.0000e+000, +9.3340e-001, +0.0000e+000, +8.2346e-001,
		+2.2082e-001, +0.0000e+000, +9.6177e-001, -1.5650e-002, +1.2708e-003,
		+0.0000e+000, -3.9913e-001, +2.8020e-002, +2.8334e-002, +8.5980e-004,
		+0.0000e+000, +3.0545e-001, -2.1691e-002, +6.4067e-004, -3.6528e-005,
		-1.1166e-004, +0.0000e+000, -7.6974e-002, -1.8986e-002, +5.6896e-003,
		-2.4159e-004, -2.3033e-004, -9.6783e-006, +0.0000e+000, -1.0218e-001,
		-1.3916e-002, -4.1025e-003, -5.1340e-005, -7.0114e-005, -3.3152e-007,
		+1.6901e-006, +0.0000e+000, -1.2422e-002, +2.5072e-003, +1.1205e-003,
		-1.3034e-004, -2.3971e-005, -2.6622e-006, +5.7852e-007, +4.5847e-008,
		+0.0000e+000, +4.4777e-002, -3.0421e-003, +2.6062e-005, -7.2421e-005,
		+1.9119e-006, +3.9236e-007, +2.2390e-007, +2.9765e-009, -4.6452e-009
	};


	const double at_mean[55] =
	{
		+1.6257e+001, +2.1224e+000, +9.2569e-001, -2.5974e+001, +1.4510e+000,
		+9.2468e-002, -5.3192e-001, +2.1094e-001, -6.9210e-002, -3.4060e-002,
		-4.6569e+000, +2.6385e-001, -3.6093e-002, +1.0198e-002, -1.8783e-003,
		+7.4983e-001, +1.1741e-001, +3.9940e-002, +5.1348e-003, +5.9111e-003,
		+8.6133e-006, +6.3057e-001, +1.5203e-001, +3.9702e-002, +4.6334e-003,
		+2.4406e-004, +1.5189e-004, +1.9581e-007, +5.4414e-001, +3.5722e-001,
		+5.2763e-002, +4.1147e-003, -2.7239e-004, -5.9957e-005, +1.6394e-006,
		-7.3045e-007, -2.9394e+000, +5.5579e-002, +1.8852e-002, +3.4272e-003,
		-2.3193e-005, -2.9349e-005, +3.6397e-007, +2.0490e-006, -6.4719e-008,
		-5.2225e-001, +2.0799e-001, +1.3477e-003, +3.1613e-004, -2.2285e-004,
		-1.8137e-005, -1.5177e-007, +6.1343e-007, +7.8566e-008, +1.0749e-009
	};


	const double bt_mean[55] =
	{
		+0.0000e+000, +0.0000e+000, +1.0210e+000, +0.0000e+000, +6.0194e-001,
		+1.2292e-001, +0.0000e+000, -4.2184e-001, +1.8230e-001, +4.2329e-002,
		+0.0000e+000, +9.3312e-002, +9.5346e-002, -1.9724e-003, +5.8776e-003,
		+0.0000e+000, -2.0940e-001, +3.4199e-002, -5.7672e-003, -2.1590e-003,
		+5.6815e-004, +0.0000e+000, +2.2858e-001, +1.2283e-002, -9.3679e-003,
		-1.4233e-003, -1.5962e-004, +4.0160e-005, +0.0000e+000, +3.6353e-002,
		-9.4263e-004, -3.6762e-003, +5.8608e-005, -2.6391e-005, +3.2095e-006,
		-1.1605e-006, +0.0000e+000, +1.6306e-001, +1.3293e-002, -1.1395e-003,
		+5.1097e-005, +3.3977e-005, +7.6449e-006, -1.7602e-007, -7.6558e-008,
		+0.0000e+000, -4.5415e-002, -1.8027e-002, +3.6561e-004, -1.1274e-004,
		+1.3047e-005, +2.0001e-006, -1.5152e-007, -2.7807e-008, +7.7491e-009
	};

	const double at_amp[55] =
	{
		-1.8654e+000, -9.0041e+000, -1.2974e-001, -3.6053e+000, +2.0284e-002,
		+2.1872e-001, -1.3015e+000, +4.0355e-001, +2.2216e-001, -4.0605e-003,
		+1.9623e+000, +4.2887e-001, +2.1437e-001, -1.0061e-002, -1.1368e-003,
		-6.9235e-002, +5.6758e-001, +1.1917e-001, -7.0765e-003, +3.0017e-004,
		+3.0601e-004, +1.6559e+000, +2.0722e-001, +6.0013e-002, +1.7023e-004,
		-9.2424e-004, +1.1269e-005, -6.9911e-006, -2.0886e+000, -6.7879e-002,
		-8.5922e-004, -1.6087e-003, -4.5549e-005, +3.3178e-005, -6.1715e-006,
		-1.4446e-006, -3.7210e-001, +1.5775e-001, -1.7827e-003, -4.4396e-004,
		+2.2844e-004, -1.1215e-005, -2.1120e-006, -9.6421e-007, -1.4170e-008,
		+7.8720e-001, -4.4238e-002, -1.5120e-003, -9.4119e-004, +4.0645e-006,
		-4.9253e-006, -1.8656e-006, -4.0736e-007, -4.9594e-008, +1.6134e-009
	};

	const double bt_amp[55] =
	{
		+0.0000e+000, +0.0000e+000, -8.9895e-001, +0.0000e+000, -1.0790e+000,
		-1.2699e-001, +0.0000e+000, -5.9033e-001, +3.4865e-002, -3.2614e-002,
		+0.0000e+000, -2.4310e-002, +1.5607e-002, -2.9833e-002, -5.9048e-003,
		+0.0000e+000, +2.8383e-001, +4.0509e-002, -1.8834e-002, -1.2654e-003,
		-1.3794e-004, +0.0000e+000, +1.3306e-001, +3.4960e-002, -3.6799e-003,
		-3.5626e-004, +1.4814e-004, +3.7932e-006, +0.0000e+000, +2.0801e-001,
		+6.5640e-003, -3.4893e-003, -2.7395e-004, +7.4296e-005, -7.9927e-006,
		-1.0277e-006, +0.0000e+000, +3.6515e-002, -7.4319e-003, -6.2873e-004,
		-8.2461e-005, +3.1095e-005, -5.3860e-007, -1.2055e-007, -1.1517e-007,
		+0.0000e+000, +3.1404e-002, +1.5580e-002, -1.1428e-003, +3.3529e-005,
		+1.0387e-005, -1.9378e-006, -2.7327e-007, +7.5833e-009, -9.2323e-009
	};

	const double ep[] = { 2000, 1, 1, 12, 0, 0 };
	double mjd, lat, lon, hgt;

	double doy, sinlat, undu;
	int i, j, k, n, m, ir;
	double dfac[20], p[10][10], ap[55], bp[55];
	double sum1, apm, apa, atm, ata, pres0, temp0;

	mjd = time2mjd(time);
	doy = mjd - 44239. - 27;

	lat = pos[0]*D2R;
	lon = pos[1]*D2R;

	// sin(latitude)
	sinlat = sin(lat);

	// degree n and order m
	n = 9;
	m = 9;

	// determine n! (faktorielle) moved by 1
	dfac[0] = 1.0;
	for (i = 1; i <= 2 * n + 1; i++)
	{
		dfac[i] = dfac[i - 1] * i;
	}

	// determine Legendre functions (Heiskanen and Moritz, Physical Geodesy, 1967, eq. 1-62)
	for (i = 0; i <= n; i++)
	{
		for (j = 0; j <= min(i, m); j++)
		{
			ir = (i - j) / 2;
			sum1 = 0.0;
			for (k = 0; k <= ir; k++)
			{
				sum1 += (pow(-1, k))*dfac[2 * i - 2 * k] / dfac[k] / dfac[i - k] / dfac[i - j - 2 * k] * pow(sinlat, i - j - 2 * k);
			}
			// Legendre functions moved by 1
			p[i][j] = 1.0 / (pow(2, i))*sqrt(pow(1.0 - sinlat*sinlat, j))*sum1;
		}
	}

	// calculate spherical harmonics
	i = 0;
	for (n = 0; n <= 9; n++)
	{
		for (m = 0; m <= n; m++)
		{
			ap[i] = p[n][m] * cos(m*lon);
			bp[i] = p[n][m] * sin(m*lon);
			i++;
		}
	}

	// Geoidal height
	undu = 0.0;
	for (i = 1; i <= 55; i++)
	{
		undu += (a_geoid[i - 1] * ap[i - 1] + b_geoid[i - 1] * bp[i - 1]);
	}

	// orthometric height
	hgt = pos[2] - undu; /* height in m (mean sea level) */
	if (hort)
	{
		*hort = hgt;
	}

	// Surface pressure on the geoid
	apm = 0.0;
	apa = 0.0;
	for (i = 0; i <55; i++)
	{
		apm += (ap_mean[i] * ap[i] + bp_mean[i] * bp[i]);
		apa += (ap_amp[i] * ap[i] + bp_amp[i] * bp[i]);
	}
	pres0 = apm + apa*cos(doy / 365.25 * 2 * PI);

	// height correction for pressure
	if (pres)
	{
		*pres = pres0*pow(1.0 - 0.0000226*hgt, 5.225);
	}

	// Surface temperature on the geoid
	atm = 0.0;
	ata = 0.0;
	for (i = 0; i <55; i++)
	{
		atm += (at_mean[i] * ap[i] + bt_mean[i] * bp[i]);
		ata += (at_amp[i] * ap[i] + bt_amp[i] * bp[i]);
	}
	temp0 = atm + ata*cos(doy / 365.25 * 2 * PI);

	// height correction for temperature
	if (temp)
	{
		*temp = temp0 - 0.0065*hgt;
	}
	if ((hort && (*hort<-100 || *hort>1e+4)) || (temp && (*temp<-100 || *temp>100))) { return 0; }
	else { return 1; }
}

/* troposphere model -----------------------------------------------------------
* compute tropospheric delay by standard atmosphere and saastamoinen model
* args   : gtime_t time     I   time
*          double *pos      I   receiver position {lat,lon,h} (rad,m)
*          double *azel     I   azimuth/elevation angle {az,el} (rad)
*          double humi      I   relative humidity
* return : tropospheric delay (m)
*-----------------------------------------------------------------------------*/
extern double tropmodel(gtime_t time, const double *pos, const double *azel,
	double humi, int flag)
{
	const double temp0 = 15.0; /* temparature at sea level */
	double hgt, pres, temp, e, z, trph, trpw;

	if (pos[2]<-100.0 || 1E4<pos[2] || azel[1] <= 0) return 0.0;

	/* standard atmosphere */
	hgt = pos[2]<0.0 ? 0.0 : pos[2];

	pres = 1013.25*pow(1.0 - 2.2557E-5*hgt, 5.2568);//5.225? 5.2568?
	temp = temp0 - 6.5E-3*hgt + 273.16;
	e = 6.108*humi*exp((17.15*temp - 4684.0) / (temp - 38.45));

	/* saastamoninen model */
	z = PI / 2.0 - azel[1] * D2R;
	trph = 0.0022768*pres / (1.0 - 0.00266*cos(2.0*pos[0] * D2R) - 0.00028*hgt / 1E3) / cos(z);
	trpw = 0.002277*(1255.0 / temp + 0.05)*e / cos(z);
	if (flag == 0) return trph;
	else if (flag == 1) return trpw;
	else
		return trph + trpw;
}

/* troposphere model -----------------------------------------------------------
* compute tropospheric delay by standard atmosphere and saastamoinen model
* args   : gtime_t time     I   time
*          double *pos      I   receiver position {lat,lon,h} (rad,m)
*          double *azel     I   azimuth/elevation angle {az,el} (rad)
*          double humi      I   relative humidity
* return : tropospheric delay (m)
*-----------------------------------------------------------------------------*/
extern double slanttropmodel(gtime_t time, const double *pos, const double *azel,double *var)
{
	const double pres0 = 1013.25, temp0 = 18.0, humi0 = 0.5; /* standard atmosphere parameters at sea level */
	const double Bs[10] = { 1.156, 1.079, 1.006, 0.938, 0.874, 0.813, 0.757, 0.654, 0.563, 0.472 };
	const double Hs[10] = { 0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 4.0, 5.0, 6.0 };
	int i;
	double pres, temp, hgt, humi, watvp, lat, zen, hgt_km, B, trop;

	if (pos[2]<-100.0 || 1E4<pos[2] || azel[1] <= 0) return 0.0;
	lat = Angle2Radian(pos[0]);
	zen = PI / 2 - Angle2Radian(azel[1]);

	if (gptModel(time, pos, &pres, &temp, &hgt))
	{
		temp = temp + 273.16;
	}
	else
	{
		hgt = pos[2]<0.0 ? 0.0 : pos[2];
		//Berg(1948) model
		pres = pres0*pow(1.0 - 2.226E-5*hgt, 5.225);
		temp = temp0 - 6.5E-3*hgt + 273.16;
	}
	humi = humi0*exp(-0.0006396*hgt);
	watvp = humi*exp(-37.2465 + 0.213166*temp - 0.000256908*temp*temp);//bernese

	hgt_km = hgt / 1000.0;
	if (hgt_km <= 0.0)
	{
		hgt_km = 0.0;
		B = Bs[0];
	}
	else if (hgt >= 6.0)
	{
		hgt_km = 6.0;
		B = Bs[9];
	}

	for (i = 0; i < 10; i++)
	{
		if (Hs[i]>hgt_km) break;
	}
	if (i == 0)
	{
		hgt_km = 0.0;
		B = Bs[0];
	}
	else
	{
		B = Bs[i - 1] + (Bs[i] - Bs[i - 1])*(hgt_km - Hs[i - 1]);
	}
	// trop = 0.0022768*pres / (1 - 0.00266*cos(2 * blh[0]) - 0.00000028*hgt)/ cos(zen)
	//    +0.002277*((1255.0 / temp + 0.05)*watvp - B*pow(tan(zen), 2.0)) / cos(zen);

	trop = 0.002277*(pres + (1255.0 / temp + 0.05)*watvp - B*pow(tan(zen), 2.0)) / cos(zen);
	*var= SQR(0.1 / sin(azel[1]*D2R));
	return trop;
}

static double interpc(const double coef[], double lat)
{
	int i = (int)(lat / 15.0);
	if (i<1) return coef[0]; else if (i>4) return coef[4];
	return coef[i - 1] * (1.0 - lat / 15.0 + i) + coef[i] * (lat / 15.0 - i);
}
static double mapf(double el, double a, double b, double c)
{
	double sinel = sin(el);
	return (1.0 + a / (1.0 + b / (1.0 + c))) / (sinel + (a / (sinel + b / (sinel + c))));
}
static double nmf(gtime_t time, const double pos[], const double azel[],
	double *mapfw)
{
	/* ref [5] table 3 */
	/* hydro-ave-a,b,c, hydro-amp-a,b,c, wet-a,b,c at latitude 15,30,45,60,75 */
	const double coef[][5] = {
		{ 1.2769934E-3, 1.2683230E-3, 1.2465397E-3, 1.2196049E-3, 1.2045996E-3 },
		{ 2.9153695E-3, 2.9152299E-3, 2.9288445E-3, 2.9022565E-3, 2.9024912E-3 },
		{ 62.610505E-3, 62.837393E-3, 63.721774E-3, 63.824265E-3, 64.258455E-3 },

		{ 0.0000000E-0, 1.2709626E-5, 2.6523662E-5, 3.4000452E-5, 4.1202191E-5 },
		{ 0.0000000E-0, 2.1414979E-5, 3.0160779E-5, 7.2562722E-5, 11.723375E-5 },
		{ 0.0000000E-0, 9.0128400E-5, 4.3497037E-5, 84.795348E-5, 170.37206E-5 },

		{ 5.8021897E-4, 5.6794847E-4, 5.8118019E-4, 5.9727542E-4, 6.1641693E-4 },
		{ 1.4275268E-3, 1.5138625E-3, 1.4572752E-3, 1.5007428E-3, 1.7599082E-3 },
		{ 4.3472961E-2, 4.6729510E-2, 4.3908931E-2, 4.4626982E-2, 5.4736038E-2 }
	};
	const double aht[] = { 2.53E-5, 5.49E-3, 1.14E-3 }; /* height correction */

	double y, cosy, ah[3], aw[3], dm, el = azel[1] * D2R, lat = pos[0], hgt = pos[2];
	int i;

	if (el <= 0.0) {
		if (mapfw) *mapfw = 0.0;
		return 0.0;
	}
	/* year from doy 28, added half a year for southern latitudes */
	y = (time2doy(time,NULL) - 28.0) / 365.25 + (lat<0.0 ? 0.5 : 0.0);

	cosy = cos(2.0*PI*y);
	lat = fabs(lat);

	for (i = 0; i<3; i++) {
		ah[i] = interpc(coef[i], lat) - interpc(coef[i + 3], lat)*cosy;
		aw[i] = interpc(coef[i + 6], lat);
	}
	/* ellipsoidal height is used instead of height above sea level */
	dm = (1.0 / sin(el) - mapf(el, aht[0], aht[1], aht[2]))*hgt / 1E3;

	if (mapfw) *mapfw = mapf(el, aw[0], aw[1], aw[2]);

	return mapf(el, ah[0], ah[1], ah[2]) + dm;
}

extern double tropmapf(gtime_t time, const double pos[], const double azel[], double *mapfw)
{
	return nmf(time, pos, azel, mapfw); /* NMF */
}

extern double prectrop(gtime_t time, const double *pos, const double *azel,
	const double *x, double *dtdx, double *var)
{
	const double zazel[] = { 0.0, 90 };
	double zhd, m_h, m_w;

	/* zenith hydrostatic delay */
	zhd = tropmodel(time, pos, zazel, 0.0, 0);

	/* mapping function */
	m_h = tropmapf(time, pos, azel, &m_w);

	dtdx[0] = m_w;
	dtdx[1] = zhd;
	*var = SQR(0.01);
	return m_h*zhd + m_w*x[0];
}

/*****************************************************************************
* Name        : modulo
* Description : Does the modulo mod of a number
* Parameters  :
* Name                           |Da|Unit|Description
* double  a                       I  N/A  Number
* double  mod		               I  N/A  Modulo base
* Returned value (double)         O  N/A  Modulo
*****************************************************************************/
extern double modulo(double a, double mod) {
	return a - ((int)(a / mod))*mod;
}

/*****************************************************************************
* Name        : scalarProd
* Description : Makes the scalar product between two vectors
* Parameters  :
* Name                           |Da|Unit|Description
* double  *a                      I  N/A  First vector
* double  *b                      I  N/A  Second vector
* Returned value (double)         O  N/A  Result vector [res = a �� b]
*****************************************************************************/
extern double scalarProd(double *a, double *b) {
	return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
/*****************************************************************************
* Name        : rotate
* Description : Rotates a 3D vector an specified angle in an axis
* Parameters  :
* Name                           |Da|Unit|Description
* double  *v                      IO N/A  Vector to rotate. Result overwrittes
*                                         this vector
* double  angle                   I  rad  Angle to rotate
* int  axis                       I  N/A  Rotation axis (1->x  2->y  3->z)
*****************************************************************************/
void rotate(double *v, double angle, int axis) {
	double		vRes[3];

	if (axis == 1) {
		vRes[0] = v[0];
		vRes[1] = v[1] * cos(angle) + v[2] * sin(angle);
		vRes[2] = -v[1] * sin(angle) + v[2] * cos(angle);
	}
	else if (axis == 2) {
		vRes[0] = v[0] * cos(angle) - v[2] * sin(angle);
		vRes[1] = v[1];
		vRes[2] = v[0] * sin(angle) + v[2] * cos(angle);
	}
	else if (axis == 3) {
		vRes[0] = v[0] * cos(angle) + v[1] * sin(angle);
		vRes[1] = -v[0] * sin(angle) + v[1] * cos(angle);
		vRes[2] = v[2];
	}

	memcpy(v, vRes, sizeof(double) * 3);
}

/*****************************************************************************
* Name        : findMoon
* Description : Obtains the position vector of the Moon in relation to Earth
*               (in ECEF). Source:
*               O. Montenbruck and G. Eberhard, Satellite Orbits, pp. 70-73, Springer, 2000
* Parameters  :
* Name                           |Da|Unit|Description
* TTime  *t                       I  N/A  Reference time
* double  *moonPosition           O  Km   Moon position at t
*****************************************************************************/
extern void findMoon(gtime_t t, double* moonPosition) {
	double	T;
	double	L0;
	double 	l;
	double	lp;
	double	F;
	double	D;
	double	longitude;
	double	latitude;
	double	distance;
	double	obliquity = 23.43929111*D2R;
	double	fday;
	double	JDN;
	double	gstr;
	int     year;
	int     doy;

	doy = time2doy(t, &year);
	fday = timediff(t, doy2time(year, doy)) / 86400;
	JDN = time2mjd(t) - 15019.5;

	T = (time2mjd(t) - 51544.5) / 36525.0;

	L0 = (218.31617 + 481267.88088*T - 1.3972*T)*D2R;
	l = (134.96292 + 477198.86753*T)*D2R;
	lp = (357.52543 + 35999.04944*T)*D2R;
	F = (93.27283 + 483202.01873*T)*D2R;
	D = (297.85027 + 445267.11135*T)*D2R;
	l = modulo(l, PI * 2);
	lp = modulo(lp, PI * 2);
	F = modulo(F, PI * 2);
	D = modulo(D, PI * 2);

	longitude = L0 + (22640 * sin(l) + 769 * sin(2 * l)
		- 4586 * sin(l - 2 * D) + 2370 * sin(2 * D)
		- 668 * sin(lp) - 412 * sin(2 * F)
		- 212 * sin(2 * l - 2 * D) - 206 * sin(l + lp - 2 * D)
		+ 192 * sin(l + 2 * D) - 165 * sin(lp - 2 * D)
		+ 148 * sin(l - lp) - 125 * sin(D)
		- 110 * sin(l + lp) - 55 * sin(2 * F - 2 * D)
		) / 3600 * D2R;

	latitude = (18520 * sin(F + longitude - L0 + (412 * sin(2 * F) + 541 * sin(lp)) / 3600 * D2R)
		- 526 * sin(F - 2 * D) + 44 * sin(l + F - 2 * D)
		- 31 * sin(-l + F - 2 * D) - 25 * sin(-2 * l + F)
		- 23 * sin(lp + F - 2 * D) + 21 * sin(-l + F)
		+ 11 * sin(-lp + F - 2 * D)
		) / 3600 * D2R;

	distance = (385000 - 20905 * cos(l) - 3699 * cos(2 * D - l)
		- 2956 * cos(2 * D) - 570 * cos(2 * l) + 246 * cos(2 * l - 2 * D)
		- 205 * cos(lp - 2 * D) - 171 * cos(l + 2 * D)
		- 152 * cos(l + lp - 2 * D)
		) * 1;
	longitude = modulo(longitude, PI * 2);
	latitude = modulo(latitude, PI * 2);
	double sinl = sin(longitude), sinp = sin(latitude), cosl = cos(longitude),
		cosp = cos(latitude);
	moonPosition[0] = distance * cos(longitude) * cos(latitude);
	moonPosition[1] = distance * sin(longitude) * cos(latitude);
	moonPosition[2] = distance * sin(latitude);

	rotate(moonPosition, -obliquity, 1);

	// Rotate from inertial to non inertial system (ECI to ECEF)
	gstr = modulo(279.690983 + 0.9856473354*JDN + 360 * fday + 180, 360)*D2R;
	rotate(moonPosition, gstr, 3);
}

/*****************************************************************************
* Name        : findSun
* Description : Obtains the position vector of the Sun in relation to Earth
*               (in ECEF).
* Parameters  :
* Name                           |Da|Unit|Description
* TTime  *t                       I  N/A  Reference time
* double  *sunPosition            O  Km   Sun position at t
*****************************************************************************/
extern void findSun(gtime_t t, double* sunPosition) {
	double	gstr;
	double	slong;
	double	sra;
	double	sdec;

	GSDtime_sun(t, &gstr, &slong, &sra, &sdec);

	sunPosition[0] = cos(sdec*D2R) * cos((sra)*D2R) * AU / 1000;
	sunPosition[1] = cos(sdec*D2R) * sin((sra)*D2R) * AU / 1000;
	sunPosition[2] = sin(sdec*D2R) * AU / 1000;

	// Rotate from inertial to non inertial system (ECI to ECEF)
	rotate(sunPosition, gstr*D2R, 3);
}

/*****************************************************************************
* Name        : GSDtime_sun
* Description : Positions the sun
* Parameters  :
* Name                           |Da|Unit|Description
* TTime  *t                       I  N/A  Reference time
* double*  gstr                   O  rad  GMST0 (to go from ECEF to inertial)
* double*  slong			       O  rad  Sun longitude
* double*  sra				       O  rad  Sun right Ascension
* double*  sdec			       O  rad  Sun declination
*****************************************************************************/
void GSDtime_sun(gtime_t t, double *gstr, double *slong, double *sra, double *sdec) 
{
	double  JDN;
	double  fday;
	double  vl;
	double  g;
	double  obliq;
	double  slp;
	double  sind;
	double  cosd;
	int     year; 
	int     doy;

	doy = time2doy(t, &year);
	fday = timediff(t, doy2time(year, doy)) / 86400;
	JDN = time2mjd(t) - 15019.5;

	vl = modulo(279.696678 + 0.9856473354*JDN, 360);
	*gstr = modulo(279.690983 + 0.9856473354*JDN + 360 * fday + 180, 360);
	g = modulo(358.475845 + 0.985600267*JDN, 360)*D2R;

	*slong = vl + (1.91946 - 0.004789*JDN / 36525)*sin(g) + 0.020094*sin(2 * g);
	obliq = (23.45229 - 0.0130125*JDN / 36525)*D2R;

	slp = (*slong - 0.005686)*D2R;
	sind = sin(obliq)*sin(slp);
	cosd = sqrt(1 - sind*sind);
	*sdec = atan2(sind, cosd) / D2R;

	*sra = 180 - atan2(sind / cosd / tan(obliq), -cos(slp) / cosd) / D2R;
}

extern void fillSolidTideDisplacement(gtime_t time, double *RecPosition, double *displacement) {
	const double	h0 = 0.6078;	// Love number h0 of degree 2
	const double	h2 = -0.0006;	// Love number h2 of degree 2
	const double	h3 = 0.292;	// Love number of degree 3
	const double	l0 = 0.0847;	// Shida number l0 of degree 2
	const double	l2 = 0.0002;	// Shida number l0 of degree 2
	const double	l3 = 0.015;	// Shide number of degree 3 
	const double	MS2E = 332946.0;	// Ratio of mass Sun to Earth
	const double	MM2E = 0.01230002;	// Ratio of mass Moon to Earth
	double			RecPos2SunPos;
	double			RecPos2MoonPos;
	double			scalarSunRec;
	double			scalarMoonRec;
	double			auxSun[3];
	double			auxMoon[3];
	double			h;
	double			l;
	double			sunPosition[3];
	double			sunDistance;
	double			sunPosUni[3];
	double			moonPosition[3];
	double			moonDistance;
	double			moonPosUni[3];
	double			receiverDistance;
	double			receiverPosUni[3];
	int				i;
	double         pos[3];


	CoorCar2CoorGeo(RecPosition, pos);

	h = h0 + h2*(3 * sin(Angle2Radian(pos[0]))*sin(Angle2Radian(pos[0])) - 1) / 2;
	l = l0 + l2*(3 * sin(Angle2Radian(pos[0]))*sin(Angle2Radian(pos[0])) - 1) / 2;

	// Find Sun position
	findSun(time, sunPosition);

	// Find Moon position
	findMoon(time, moonPosition);
	sunDistance = norm(sunPosition, 3);
	moonDistance = norm(moonPosition, 3);
	receiverDistance = norm(RecPosition, 3);

	for (i = 0; i<3; i++) {
		sunPosUni[i] = sunPosition[i] / sunDistance;
		moonPosUni[i] = moonPosition[i] / moonDistance;
		receiverPosUni[i] = RecPosition[i] / receiverDistance;
	}
	receiverDistance /= 1000; // To transform from m to km

							  // Computing scalar products
	scalarSunRec = scalarProd(sunPosUni, receiverPosUni);
	scalarMoonRec = scalarProd(moonPosUni, receiverPosUni);

	// Computing auxiliar vectors
	for (i = 0; i<3; i++) {
		auxSun[i] = sunPosUni[i] - scalarSunRec*receiverPosUni[i];
		auxMoon[i] = moonPosUni[i] - scalarMoonRec*receiverPosUni[i];
	}

	// Distance relations	
	RecPos2SunPos = receiverDistance / sunDistance;
	RecPos2MoonPos = receiverDistance / moonDistance;

	// Computing displacements
	for (i = 0; i<3; i++) {
		displacement[i] = 0;

		// Degree 2
		displacement[i] += (
			MS2E * RecPos2SunPos * RecPos2SunPos * RecPos2SunPos * receiverDistance *( 	// Sun
				h * receiverPosUni[i] * (3.0 / 2.0*scalarSunRec*scalarSunRec - 1.0 / 2.0) +
				3.0 * l * scalarSunRec * auxSun[i]) +
			MM2E * RecPos2MoonPos * RecPos2MoonPos * RecPos2MoonPos * receiverDistance *( 	// Moon
				h * receiverPosUni[i] * (3.0 / 2.0*scalarMoonRec*scalarMoonRec - 1.0 / 2.0) +
				3.0 * l * scalarMoonRec * auxMoon[i])
			) * 1000; // To transform from km to m

					  // Degree 3
		displacement[i] += (
			MM2E * RecPos2MoonPos * RecPos2MoonPos * RecPos2MoonPos * RecPos2MoonPos * receiverDistance *(   // Only Moon 
				h3 * receiverPosUni[i] * (5.0 / 2.0*scalarMoonRec*scalarMoonRec*scalarMoonRec - 3.0 / 2.0*scalarMoonRec) +
				l3 * (15.0 / 2.0*scalarMoonRec*scalarMoonRec - 3.0 / 2.0) * auxMoon[i])
			) * 1000; // To transform from km to m
	}
}



/* interpolate antenna phase center variation --------------------------------*/
static double interpvarele(double ang, const double *var)
{
	double a = ang / 5.0; /* ang=0-90 */
	int i = (int)a;
	if (i<0) return var[0]; else if (i >= 18) return var[18];
	return var[i] * (1.0 - a + i) + var[i + 1] * (a - i);
}
/* interpolate antenna phase center variation --------------------------------*/
static double interpvar(double ang, double azi, const double *var, const double(*azivar)[19], double dazi)
{
	double a, var1, var2; /* ang=0-90 */
	int i, nazi;

	if (dazi == 0) {
		return interpvarele(ang, var);
	}
	else {
		nazi = (int)(360 / dazi);
		a = azi / dazi;
		i = (int)a;
		if (i<0) return interpvarele(ang, azivar[0]);
		else if (i >= nazi) return interpvarele(ang, azivar[nazi]);
		else {
			var1 = interpvarele(ang, azivar[i]);
			var2 = interpvarele(ang, azivar[i + 1]);
			return var1*(1.0 - a + i) + var2*(a - i);
		}

	}
}
/* receiver antenna model ------------------------------------------------------
* compute antenna offset by antenna phase center parameters
* args   : pcv_t *pcv       I   antenna phase center parameters
*          double *azel     I   azimuth/elevation for receiver {az,el} (rad)
*          int     opt      I   option (0:only offset,1:offset+pcv)
*          double *dant     O   range offsets for each frequency (m)
* return : none
* notes  : current version does not support azimuth dependent terms
*-----------------------------------------------------------------------------*/
extern void antmodel(pcv_t *pcv, const double *del, const double *azel,
	int opt, int sys, double *dant)
{
	double e[3], off[3], cosel = cos(azel[1] * D2R);
	int i, j;
	//	int ind = 0;֮ǰ������ѡ��gps��glonass����

	e[0] = sin(azel[0] * D2R)*cosel;
	e[1] = cos(azel[0] * D2R)*cosel;
	e[2] = sin(azel[1] * D2R);

	for (i = 0; i<NFREQ; i++) {
		for (j = 0; j<3; j++)
			off[j] = pcv->off[i][j] + del[j];

		//		dant[i] = -dot_vector(off, e, 3) + (opt ? interpvar(90.0 - azel[1], azel[0], pcv->var[ind][i], pcv->azivar[ind][i], pcv->dazi) : 0.0);
		dant[i] = -dot_vector(off, e, 3) + (opt ? interpvarele(90.0 - azel[1], pcv->var[i]) : 0.0);

	}
}
/* satellite antenna model ------------------------------------------------------
* compute satellite antenna phase center parameters
* args   : pcv_t *pcv       I   antenna phase center parameters
*          double nadir     I   nadir angle for satellite (rad)
*          double *dant     O   range offsets for each frequency (m)
* return : none
*-----------------------------------------------------------------------------*/
extern void antmodel_s(const pcv_t *pcv, double nadir, double *dant)
{
	int i;

	for (i = 0; i<NFREQ; i++) {
		dant[i] = interpvarele(nadir*R2D*5.0, pcv->var[i]);
	}
}

//E is the trans of E in RTKLIB
extern void xyz2enu(const double *pos, double *E)
{
	double sinp = sin(pos[0] * D2R), cosp = cos(pos[0] * D2R), sinl = sin(pos[1] * D2R), cosl = cos(pos[1] * D2R);

	E[0] = -sinl;      E[1] = cosl;       E[2] = 0.0;
	E[3] = -sinp*cosl; E[4] = -sinp*sinl; E[5] = cosp;
	E[6] = cosp*cosl;  E[7] = cosp*sinl;  E[8] = sinp;
}

/*----------------------------------------------------------------------------
* Name        : rotateAroundZ
* Description : coordinate rotation around z-axis with a given angle
* Parameters  : alpha     double     I       angle(rad)
*               *X        double     I/O     coordinate matrix before and after rotated (3x3)
* Return      : none
----------------------------------------------------------------------------*/
extern void  rotateAroundZ(double alpha, double *X)
{
	double T[9], Xt[9];

	matcpy(Xt, X, 3, 3);
	T[0] = cos(alpha); T[1] = sin(alpha);  T[2] = 0.0;
	T[3] = -T[1];  T[4] = T[0];    T[5] = 0.0;
	T[6] = 0.0;    T[7] = 0.0;     T[8] = 1.0;

	matmul("NN", 3, 3, 3, 1.0, T, Xt, 0.0, X);
}

/* phase windup correction -----------------------------------------------------
* phase windup correction (ref [7] 5.1.2)
* args   : gtime_t time     I   time (GPST)
*          double  *rs      I   satellite position (ecef) {x,y,z} (m)
*          double  *rr      I   receiver  position (ecef) {x,y,z} (m)
*          double  *phw     IO  phase windup correction (cycle)
* return : none
* notes  : the previous value of phase windup correction should be set to *phw
*          as an input. the function assumes windup correction has no jump more
*          than 0.5 cycle.
*-----------------------------------------------------------------------------*/
extern void windupcorr(gtime_t time, const double *rs, const double *rr, const double rotation,
	double *phw)
{
	double ek[3], exs[3], eys[3], ezs[3], ess[3], exr[3], eyr[3], eks[3], ekr[3], E[9];
	double dr[3], ds[3], drs[3], r[3], pos[3], rsun[3], cosp, ph;
	int i;
	/* sun position in ecef */
	findSun(timeadd(time, -leapsecond(time)), rsun);

	/* unit vector satellite to receiver */
	for (i = 0; i<3; i++) r[i] = rr[i] - rs[i];
	if (!normv3(r, ek)) return;

	/* unit vectors of satellite antenna */
	for (i = 0; i<3; i++) r[i] = -rs[i];
	if (!normv3(r, ezs)) return;
	for (i = 0; i<3; i++) r[i] = rsun[i] - rs[i];
	if (!normv3(r, ess)) return;
	cross3(ezs, ess, r);
	if (!normv3(r, eys)) return;
	cross3(eys, ezs, exs);

	/* unit vectors of receiver antenna */
	CoorCar2CoorGeo(rr, pos);
	xyz2enu(pos, E);
	rotateAroundZ(-rotation, E);//T'E' to match with rtklib
	exr[0] = E[1]; exr[1] = E[4]; exr[2] = E[7]; /* x = north */
	eyr[0] = -E[0]; eyr[1] = -E[3]; eyr[2] = -E[6]; /* y = west  */

													/* phase windup effect */
	cross3(ek, eys, eks);
	cross3(ek, eyr, ekr);
	for (i = 0; i<3; i++) {
		ds[i] = exs[i] - ek[i] * dot_vector(ek, exs, 3) - eks[i];
		dr[i] = exr[i] - ek[i] * dot_vector(ek, exr, 3) + ekr[i];
	}
	cosp = dot_vector(ds, dr, 3) / norm(ds, 3) / norm(dr, 3);
	if (cosp<-1.0) cosp = -1.0;
	else if (cosp> 1.0) cosp = 1.0;
	ph = acos(cosp) / 2.0 / PI;
	cross3(ds, dr, drs);
	if (dot_vector(ek, drs, 3)<0.0) ph = -ph;

	*phw = ph + floor(*phw - ph + 0.5); /* in cycle */
}

extern void satantoff(gtime_t time, const double *rs, int sat, const nav_t *nav,
	double *dant)
{
	const double *lam = nav->lam[sat - 1];
	const pcv_t *pcv = nav->pcvs + sat - 1;
	double ex[3], ey[3], ez[3], es[3], r[3], rsun[3];
	double gamma, C1, C2, dant1, dant2;
	int i, j = 0, k = 1/*, ind = 0*/;


	/* sun position in ecef */
	findSun(timeadd(time, -leapsecond(time)), rsun);

	/* unit vectors of satellite fixed coordinates */
	for (i = 0; i<3; i++) r[i] = -rs[i];
	if (!normv3(r, ez)) return;
	for (i = 0; i<3; i++) r[i] = rsun[i] - rs[i];
	if (!normv3(r, es)) return;
	cross3(ez, es, r);
	if (!normv3(r, ey)) return;
	cross3(ey, ez, ex);

	if (NFREQ >= 3 && (satIndex2sys(sat)&(SYS_GAL | SYS_SBS))) k = 2;

	if (NFREQ<2 || lam[j] == 0.0 || lam[k] == 0.0) return;

	gamma = SQR(lam[k]) / SQR(lam[j]);
	C1 = gamma / (gamma - 1.0);
	C2 = -1.0 / (gamma - 1.0);

	/* iono-free LC */
	for (i = 0; i<3; i++) {//i=0,1,2->dx,dy,dz in ECEF
		dant1 = pcv->off[j][0] * ex[i] + pcv->off[j][1] * ey[i] + pcv->off[j][2] * ez[i];
		dant2 = pcv->off[k][0] * ex[i] + pcv->off[k][1] * ey[i] + pcv->off[k][2] * ez[i];
		dant[i] = C1*dant1 + C2*dant2;//PCO same on L1/L2/LC
	}

}



/* compute dops ----------------------------------------------------------------
* compute DOP (dilution of precision)
* args   : int    ns        I   number of satellites
*          double *azel     I   satellite azimuth/elevation angle (rad)
*          double elmin     I   elevation cutoff angle (rad)
*          double *dop      O   DOPs {GDOP,PDOP,HDOP,VDOP}
* return : none
* notes  : dop[0]-[3] return 0 in case of dop computation error
*-----------------------------------------------------------------------------*/
#define SQRT(x)     ((x)<0.0?0.0:sqrt(x))

extern void dops(int ns, const double *azel, double elmin, double *dop)
{
	double H[4 * MAXSAT], Q[16], cosel, sinel;
	int i, n;

	for (i = 0; i<5; i++) dop[i] = 0.0;
	for (i = n = 0; i<ns&&i<MAXSAT; i++) {
		if (azel[1 + i * 2]<elmin || azel[1 + i * 2] <= 0.0) continue;
		cosel = cos(azel[1 + i * 2] * D2R);
		sinel = sin(azel[1 + i * 2] * D2R);
		H[4 * n] = cosel*sin(azel[i * 2] * D2R);
		H[1 + 4 * n] = cosel*cos(azel[i * 2] * D2R);
		H[2 + 4 * n] = sinel;
		H[3 + 4 * n++] = 1.0;
	}
	if (n<4) return;

	matmul("TN", 4, 4, n, 1.0, H, H, 0.0, Q);
	if (!matinv(Q, 4)) {
		dop[0] = SQRT(Q[0] + Q[5] + Q[10] + Q[15]); /* GDOP */
		dop[1] = SQRT(Q[0] + Q[5] + Q[10]);       /* PDOP */
		dop[2] = SQRT(Q[0] + Q[5]);             /* HDOP */
		dop[3] = SQRT(Q[10]);                 /* VDOP */
		dop[4] = SQRT(Q[15]);					/* TDOP */
	}
}



/* convert degree to deg-min-sec -----------------------------------------------
* convert degree to degree-minute-second
* args   : double deg       I   degree
*          double *dms      O   degree-minute-second {deg,min,sec}
*          int    ndec      I   number of decimals of second
* return : none
*-----------------------------------------------------------------------------*/
extern void deg2dms(double deg, double *dms, int ndec)
{
	double sign = deg<0.0 ? -1.0 : 1.0, a = fabs(deg);
	double unit = pow(0.1, ndec);
	dms[0] = floor(a); a = (a - dms[0])*60.0;
	dms[1] = floor(a); a = (a - dms[1])*60.0;
	dms[2] = floor(a / unit + 0.5)*unit;
	if (dms[2] >= 60.0) {
		dms[2] = 0.0;
		dms[1] += 1.0;
		if (dms[1] >= 60.0) {
			dms[1] = 0.0;
			dms[0] += 1.0;
		}
	}
	dms[0] *= sign;
}
/* convert deg-min-sec to degree -----------------------------------------------
* convert degree-minute-second to degree
* args   : double *dms      I   degree-minute-second {deg,min,sec}
* return : degree
*-----------------------------------------------------------------------------*/
extern double dms2deg(const double *dms)
{
	double sign = dms[0]<0.0 ? -1.0 : 1.0;
	return sign*(fabs(dms[0]) + dms[1] / 60.0 + dms[2] / 3600.0);
}

extern void InitialSolution(sol_t* sol, const prcopt_t* popt)
{
	sol->opt = *popt;
}

extern void releaseSolution(sol_t* sol)
{
	if (sol->x != NULL) { free(sol->x); sol->x = NULL; }
	if (sol->P != NULL) { free(sol->P); sol->P = NULL; }
}


